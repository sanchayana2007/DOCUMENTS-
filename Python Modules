											Contents:
											---------
									1. Expertising OOPs
										> Ways of Sub Classes Initialization:
										> Composite objects
										> ABCs of Consistent Design
										> Abstract class
										> Callable
									2. Object serialisation
										> Json
									3. String Parsing Modules 
										>String 
										>Regex
									4. Utility Modules 
										>Itertools Module
										>Functools Module
										> Utility
									5. Debugging Modules
											Pdb
									6. Unit test Modules 
									7. File parsing Modules     
									8. Gui Modules
											
											Tkinter
									9. Database Modules (ORM)    
									10. Web Server  Modules 
									11. Event based Modules 
									12. OS handling Modules   
									13. Web Scarping  Modules
										Crawling : Request/Urllib
										
										Scraping : 
											scrapy 
											beautifulsoap
										
									14. DataAnalytics Modules
									15. Automation Modules
										Selenium 
										
									16. Protocol Modules  
									17. Threading  
									18. Python Packaging :
											Py2exe,setuptools
									19. Memory Profiling :
										Heapy, 
										Guppy 
									20. Graph Plotting (BI):
										MplotLib 
										Mplot3d
									
											
Python Packages all included in an Instllation : https://www.activestate.com/activepython


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                          1.  Expertising OOPs                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Subclass Initialization Ways 
1> Sub Classes Initialization:
-------------------------------
This deals with a instance atributes when some atribues differes according to type 
of the subclass based on Some Atribute , So those inputs are preintialised from the instaces 
class Card:
	def __init__( self, rank, suit ):
		self.suit= suit
		self.rank= rank
		self.hard, self.soft = self._points()
class NumberCard( Card ):
	def _points( self ):
		return int(self.rank), int(self.rank)
class AceCard( Card ):
	def _points( self ):
		return 1, 11
class FaceCard( Card ):
	def _points( self):
		return 10, 10


cards = [ AceCard('A', '♠'), NumberCard('2','♠'), NumberCard('3','♠'),
]

2> Leveraging __init__() via a factory function:
----------------------------------------------------
In Python, a class isn't required. It's merely a good idea when there are 
related factories that are complex. One of the strengths of Python is that we're

def card( rank, suit ):
	#  Ace / Num Card objs are just returned 
	if rank == 1: return AceCard( 'A', suit )
		elif 2 <= rank < 11: return NumberCard( str(rank), suit )
		elif 11 <= rank < 14:
		# here there is a Multi condition check by using a Map in a line
			name = { 11: 'J', 12: 'Q', 13: 'K' }[rank]
			return FaceCard( name, suit )
		else:
			raise Exception( "Rank out of range" )
					OR
3> Mapping to a tuple of values:
------------------------------------
The following is the essence of how mapping is done to a two-tuple:
class_, rank_str= {
	1: (AceCard,'A'),
	11: (FaceCard,'J'),
	12: (FaceCard,'Q'),
	13: (FaceCard,'K'),
	}.get(rank, (NumberCard, str(rank)))
	return class_( rank_str, suit )
4> fluent Card factory class:
---------------------------
We make the setting of the rank object a fluent method that
returns self. Setting the suit object will actually create the Card instance.
class CardFactory:
	def rank( self, rank ):
		self.class_, self.rank_str= {1:(AceCard,'A'),
		11:(FaceCard,'J'),
			12:(FaceCard,'Q'),
			13:(FaceCard,'K'),
			}.get(rank, (NumberCard, str(rank)))
		return self
	def suit( self, suit ):
		return self.class_( self.rank_str, suit )
card8 = CardFactory()
deck8 = [card8.rank(r+1).suit(s) for r in range(13) for s in (Club,
Diamond, Heart, Spade)]

Simple composite objects
---------------------------
A composite object can also be called a container.use a simple list as a deck.
Before designing a new class, we need to ask this question: is using a simple
list appropriate?
We can use random.shuffle() to shuffle the deck and deck.pop() to deal cards
into a player's Hand.
so for this 2 functionalities y to put a new class
To design a collection of objects, we have the following three general design strategies:
• Wrap: This design pattern is an existing collection definition. This might be
an example of the Facade design pattern.
• Extend: This design pattern is an existing collection class. This is ordinary
subclass definition.
• Invent: This is designed from scratch. We'll look at this in Chapter 6, Creating
Containers and Collections.


1) Wrapping a collection class:
The following is a wrapper design that contains an internal collection:
class Deck:
	def __init__( self ):
		self._cards = [card6(r+1,s) for r in range(13) for s in (Club,
		Diamond, Heart, Spade)]
		random.shuffle( self._cards )
	def pop( self ):
		return self._cards.pop()
We've defined Deck so that the internal collection is a list object. 
The pop() method of Deck simply delegates to the wrapped list object.
We can then create a Hand instance with the following kind of code:
	d= Deck()
	hand= [ d.pop(), d.pop() ]
A Facade design pattern or wrapper class contains methods that are
simply delegated to the underlying implementation class. This delegation can
become wordy. For a sophisticated collection, we may wind up delegating a large
number of methods to the wrapped object.
2) Extending a collection class:
An alternative to wrapping is to extend a built-in class. 
By doing this, we have the
	> advantage of not having to reimplement the pop() method; we can simply inherit it.
	> The advantage that it creates a class without writing too much code.
	< In this example, extending the list class has the disadvantage that this
provides many more functions than we truly need.
class Deck2( list ):
	def __init__( self ):
		super().__init__( card6(r+1,s) for r in range(13) for s in
		(Club, Diamond, Heart, Spade) )## create the deck list 
		random.shuffle( self )## Shuffle the cards
3) invent : Asd this approach goes up the building a new implementation 
following is Deck definition that contains multiple sets of 52-card decks:
class Deck3(list):
	def __init__(self, decks=1):
		super().__init__()
		for i in range(decks):
			self.extend( card6(r+1,s) for r in range(13) for s in
			(Club, Diamond, Heart, Spade) )
		random.shuffle( self )
		burn= random.randint(1,52)
		for i in range(burn): self.pop()
		
Here, we used the __init__() superclass to build an empty collection. Then, we
used self.extend() to append multiple 52-card decks to the shoe. We could also
use super().extend() since we did not provide an overriding implementation in
this class.
The same could hace achieved by the 2.extending code using a deeply nested loop for 
intialising super.__init__

( card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart,
Spade) for d in range(decks) )

Complete composite object initialization
------------------------------------------
Ideally, the __init__() initializer method will create a complete instance of an
object. This is a bit more complex when creating a complete instance of a container
that contains an internal collection of other objects.
class Hand2:
	def __init__( self, dealer_card, *cards ):
		self.dealer_card= dealer_card
		self.cards = list(cards)
Stateless objects without __init__()
The following is an example of a degenerate class that doesn't need an __init__()
method. It's a common design pattern for Strategy objects. A Strategy object is plugged
into a Master object to implement an algorithm or decision

Initialization with type validation
Type validation is rarely a sensible requirement. In a way, this might be a failure
to fully understand Python. The notional objective is to validate that all of the
arguments are of a proper type. The issue with trying to do this is that the definition
of proper is often far too narrow to be truly useful.
This is different from validating that objects meet other criteria. Numeric range
checking, for example, may be essential to prevent infinite loops.
What can create problems is trying to do something like the following in an
__init__() method:
class ValidPlayer:
def __init__( self, table, bet_strategy, game_strategy ):
assert isinstance( table, Table )
assert isinstance( bet_strategy, BettingStrategy )
assert isinstance( game_strategy, GameStrategy )
self.bet_strategy = bet_strategy
Initializing static methods
-----------------------------:
When we have multiple ways to create an object, it's sometimes more clear
 to use static
methods to create and return instances rather than complex __init__() methods.
class Hand5:
def __init__( self, dealer_card, *cards ):
self.dealer_card= dealer_card
self.cards = list(cards)
@staticmethod
def freeze( other ):
hand= Hand5( other.dealer_card, *other.cards )
return hand

h = Hand5( d.pop(), d.pop(), d.pop() )
s1, s2 = Hand5.freeze()

ABCs of Consistent Design:
=============================================================
Python 3.2, the abstract base classes for collections were buried in collections.
In Python 3.3, however, the abstract base classes have been split into a separate
submodule named collections.abc.
We'll also look at the numbers module, because it contains ABCs for numeric types.
There are abstract base classes for I/O in the io module too.
. Abstract : Subclass must override some methods
. Base : Other Class will use it as a super class

Callable:
---------------
functional objects which is required , any class with a __call__ method
collections.abc.Callable.
** We should make evry call class defination a proper subclass for 
collections.abc.Callable

>>> abs(3)
3
>>> isinstance(abs, collections.Callable)
True
isinstance( {}, collections.abc.Mapping )

isinstance( 355/113, numbers.Number )
True

>>>isinstance( x_iter, collections.abc.Iterator )
True

The entire family tree of built-in containers is reflected in the abstract base classes.
Lower-level features include Container, Iterable, and Sized.
Higher-level features include the following characteristics:

• Sequence and MutableSequence: These are the abstractions of the concrete
classes list and tuple. Concrete sequence implementations also include
bytes and str.
• MutableMapping: This is the abstraction of dict. It extends Mapping, but
there's no built-in concrete implementation of this.
• Set and MutableSet: These are the abstractions of the concrete classes,
frozenset and set.
This allows us to build new classes or extend existing classes

How the Abstarct behaviour is taken care off:
-----------------------------------------------
This module
includes the ABCMeta class that provides several features.
1) First, the ABCMeta class assures that abstract classes can't be instantiated. A subclass
that provides all of the required definitions, however, can be instantiated. The
metaclass will invoke the abstract class's special method, __subclasshook__(),
as a part of processing __new__(). If that method returns NotImplemented, then an
exception will be raised to show that the class didn't define all the required methods.

2) Second, it provides definitions for __instancecheck__() and __subclasscheck__
(). These special methods implement the isinstance() and issubclass() built-in
functions. They provide the checks to confirm that an object (or a class) belongs to
the proper ABC. This includes a cache of subclasses to speed up the testing.

The abc module also includes a number of decorators for creating abstract method
 The most important of these is the @abstractmethod decorator.
 

Abstract class Implementation (OOPS_in_python_100.py)
----------------------------------------
class AbstractEntity(metaclass=ABCMeta):
    __slots__ = ()
    @abstractmethod
    def func1(self):
        return 1

    @classmethod
    def __subclasshook__(cls, subclass):
        if cls is Hand:
            if any('func1' in B.__dict__ for B in subclass.__mro__):
                return True
            return NotImplemented

class Entity(AbstractEntity):
    def test(self):
        pass
    def func1(self):
        print('derived')

Now if you dont implement the Abstract method func1 the instance creation from entity will throw up an error 
saying that the Abstarct Method is not implemented .
** You can change the signature of func1 is derived and  not very sure of subclasshook as it didnt got called 

creating a Callable class :
----------------------------
> Using the def statement to create a function

> By creating an instance of a class that uses collections.abc.Callable as its base class.

import collections.abc
class Power1( collections.abc.Callable ):
	def __init__(self):
		self.i = 23
	
	def __call__( self, x, n ):
		p= 1
		for i in range(n):
			p *= x
			return p
pow1= Power1()
pow1(2,4)

** So now if we dont define the call it wull create a Error and we are ask to overide the 
__call__ method .

Optimisation by divide and conquer by calling __call__ recursively inder a function 

class Power4( abc.Callable ):
	def __call__( self, x, n ):
		if n == 0: return 1
		elif n % 2 == 1:
			return self.__call__(x, n-1)*x
		else: # n % 2 == 0:
		t= self.__call__(x, n//2)
		return t*t

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                         2.  Object serialisation                                              	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Serialisation:
-----------------
Convertion of Python objects in bytes and write the bytes to a file called this as 
serialisation .

Serialisationl of python Objects :
-----------------------------------
> to have a persistance in Local file
> exchange objects between Applications 
(simple persistence using libraries focused on various data representations: JSON, YAML, 
pickle, XML, and CSV)
pickel (Object_serialisation_200.py)

There are ways to perform incremental serialization, but they involve extra work.
Single Python serialised objects (list of Objects can be serialised as one)

Perssistance:
-------------
Usually python objects lives only as long as there is a reference associated with the 
object to make an objects lifetime beyond running of the python program is called 
Persistane.
This can be acieved by writing the objects in files Class definitions exist
primarily as source code. The class definition in the volatile memory is rebuilt from
the source (or the byte-code version of the source) every time it's needed .

Python terminology tends to focus on the words dump and load. 
• dump(object, file): This will dump the given object to the given file
• dumps(object): This will dump an object, returning a string representation
• load(file): This will load an object from the given file, returning the
constructed object
• loads(string): This will load an object from a string representation,
returning the constructed object.
Block n Char Mode :
---------------------
Block-mode devices can also be called seekable
because the OS supports a seek operation that can access any byte in the file in an
arbitrary order.

Character-mode devices are not seekable; they are interfaces where
bytes are transmitted serially.
Modules:
---------
JSON ()
Pickel (single objects saved to binary files ; multiple objects can set as list)[Object_serialisation_200.py]
shelve(complex—typically objects that
contain other objects)

Json/REST/XML/SOAP Web Services :
-------------------------------
Restful APIs:
----------------

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                         3.  String parsing Modules                                                +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Strings:
======================================




Reg Expresions:
======================================
A reg ex consist of literals and metacharacters
Literals : Actual text viz san
---------
Metachar : re matching chars (? * /w )
----------
We can use metacharacters as if they were literals. There are three mechanisms
to do so:
• Escape the metacharacters by preceding them with a backslash.
• In python, use the re.escape method to escape non-alphanumeric
characters that may appear in the expression. 

twelve metacharacters that should be escaped:
---------------------------------------------
Backslash \
• Caret ^
• Dollar sign $
• Dot .
• Pipe symbol |
• Question mark ?
• Asterisk *
• Plus sign +
• Opening parenthesis (
• Closing parenthesis )
• Opening square bracket [
• The opening curly brace {

Character classes
--------------------
Element 		Description
[ 			Matches the following set of characters
0-9 		Matches anything between 0 and 9 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).
Or
a-z 		Matches anything between a and z (a, b, c, d, ..., z)
Or
A-Z 		Matches anything between A and Z (A, B, C, D, ..., Z)
] 			End of character set

We can invert the meaning
of a character set by placing a caret (^) symbol right after the opening square
bracket metacharacter ([).

 [^0-9] will match anything that is not a digit.
 Well-known shortcuts for typical character sets
---------------------------------------------------
Element 	Description (for regex with default flags)
-----------------------------------------------------------------------\\\\\
.  			any character except newline \n
\d  		any decimal digit; this is equivalent to the class [0-9]
\D 			any non-digit character; this is equivalent to the class [^0-9]
\s 			any whitespace character equivalent to [⇢\t\n\r\f\v]
\S 			any non-whitespace character equivalent to [^ \t\n\r\f\v]
\w  		any alphanumeric character; equivalent to [a-zA-Z0-9_]
\W 			any non-alphanumeric character;  equivalent to [^a-zA-Z0-9_]

The special character matches :
------------------------------------
Element 		Description
-------------------------------------
[ 				Matches a set of characters
^ 				Not matching this symbol's following characters
\/ 				Matches a / character
\ 				Matches a \ character
] 				End of the set

Alternation:(Matching a set regular expression)
---------------------------------------------
we want to match either if we find the word "yes"
or the word "no". Using alternation, it will be as simple as:
	/yes|no/
	
Quantifiers:(mechanisms to define how 
character, metacharacter, or character set can be repeated.)
-----------------------------------------------------------
Symbol  Quantification of previous character
? 		Optional (0 or 1 repetitions)
* 		Zero or more times
+ 		One or more times
{n,m} 	Curly braces Between n and m times	

ex:  /cars?/ = to match the word car and its plural form cars
ex: 555-555-555, 555 555 555,or 555555555= /\d+[-\s]?\d+[-\s]?\d+/
Element 	Type 					Description
\d 		Predefined character set 	Any decimal character
+ 		Quantifier - 				that is repeated one or more times
[-\s] 	Character set 				A hyphen or whitespace character
? 		Quantifier - 				that may or may not appear
\d 		Predefined character set 	Any decimal character
+ 		Quantifier - 				that is repeated one or more times
[-\s] 	Character set 				A hyphen or whitespace character
\d 		Predefined character set 	Any decimal character
+ 		Quantifier - 				that is repeated one or more times
	
Syntax 	Description
{n} 	The previous character is repeated exactly n times.
{n,} 	The previous character is repeated at least n times.
{,n} 	The previous character is repeated at most n times.
{n,m} 	The previous character is repeated between n and m times(both inclusive).
now 
 555-555-555, 555 555 555,or 555555555 = \d{1,3}[-\s]?\d{3}[-\s]?\d{3}/

Greedy and reluctant quantifiers
----------------------------------
The greedy behavior of the quantifiers is applied by default in the quantifiers.
A greedy quantifier will try to match as much as possible to have the biggest
match result possible
Ex:
match a /".+"/ in English "Hello", Spanish "Hola" will match 
"Hello", Spanish "Hola"

The non-greedy behavior can be requested by adding an extra question mark
to the quantifier; for example, ??, *? or +?. A quantifier marked as reluctant
will behave like the exact opposite of the greedy ones. They will try to have
the smallest match possible.
Ex:
match a /".+?"/ in English "Hello", Spanish "Hola" will match 
"Hello"  "Hola"

Boundary Matchers:(Matching Begining or End in line match)
----------------------------------------------------------
Matcher 		Description
^ 				Matches at the beginning of a line
$ 				Matches at the end of a line
\b 				Matches a word boundary
\B 				Matches the opposite of \b. Anything that is not a word boundary
\A 				Matches the beginning of the input
\Z 				Matches the end of the input

Ex:
a regular expression that
will match lines that start with "Name:" = /^Name:/
Ex:
"Name:VVVHUHU"    /^Name:[\sa-zA-Z]+$/


String Python 2.x
-------------------------
1. String 			String literals. They're encoded automatically by
				using the default encoding (UTF-8 in our case).
				The backslash is necessary to escape meaningful
				characters.
>>>"España \n"
'Espa\xc3\xb1a \n'

2) Raw string r or R They're equal to literal strings with the exception
				of the backslashes, which are treated as normal
				characters.
>>>r"España \n"
'Espa\xc3\xb1a \\n'
3) Unicode 		string u or U These strings use the Unicode character set 
				(ISO 10646).
>>>u"España \n"
u'Espa\xf1a \n'
4)Unicode raw
		string
				ur or UR They're Unicode strings but treat backslashes as
				normal raw strings.
>>>ur"España \n"
u'Espa\xf1a \\n'

Building blocks for Python regex:
---------------------------------
• RegexObject: It is also known as Pattern Object. It represents a compiled
regular expression
• MatchObject: It represents the matched pattern

>>> pattern = re.compile(r'<HTML>')
>>> pattern.match("<HTML>")
<_sre.SRE_Match at 0x108076578>

if we want to know if a string starts with <HTML>, we can use the following code:
There are two ways two get that 
1> Compile a pattern, which gives us a RegexObject,
2> we can use the module operations
1> Compile a pattern, which gives us a RegexObject:
----------------------------------------------------
1>  re-use the regular expression, we can use the following code:

>>> pattern = re.compile(r'<HTML>')
>>> pattern.match("<HTML>")
2> we can directly perform the operation on the module using the:
----------------------------------------------------
>>> re.match(r'<HTML>', "<HTML>")

Advantages with Compiled RegexObject:
---------------------------------------
When you're using module operations, you don't control the cache,
and so you can end up with a lot of memory usage. You can always 
use re.purge to clear the cache but this is a tradeoff with performance. 
Using compiled patterns allows you to have a fine-grained control of
the memory consumption because you can decide when to purge them

Searching( to look for patterns in strings)
------------------------------------------------
Two operations  match and search;
1> match :match the compiled pattern only at the beginning of the string.
---------------------------------------------------------
Ex:
optional pos parameter specifies where to start searching
pattern.match("--<HTML>", 2)
<_sre.SRE_Match at 0x1043bc850>
The second argument, endpos, sets how far the pattern will try to match in the
string
>>> pattern = re.compile(r'<HTML>$')
>>> pattern.match("<HTML>⇢", 0,6)
<_sre.SRE_Match object at 0x1007033d8>
>>> pattern.match("<HTML>⇢"[:6])
<_sre.SRE_Match object at 0x100703370>
2> search :tries to match the pattern at any location of the string and not 
---------------------------------------------------------
Ex:
>>> pattern.search("->HTML>")
<_sre.SRE_Match at 0x108076578>

Multiline there will be a single match in each line 
find <HTML> right after new line, thanks to re.MULTILINE.
>>> pattern = re.compile(r'^<HTML>', re.MULTILINE)
>>> pattern.search("<HTML>")
	<_sre.SRE_Match at 0x1043d3100>
>>> pattern.search("-<HTML>")
	None
>>> pattern.search("--\n<HTML>")
	<_sre.SRE_Match at 0x1043bce68>

3> findall : it returns a list with all the non-overlapping occurrences of a pattern
--------------------------------------------------------------
>>> pattern = re.compile(r"\w+")
>>> pattern.findall("hello world")
['hello', 'world]
4> finditer: it returns an iterator in which each element is a MatchObject
--------------------------------------------------------------
Match every two words and capture them:
>>> pattern = re.compile(r"(\w+) (\w+)")
>>> it = pattern.finditer("Hello⇢world⇢hola⇢mundo")
>>> match = it.next()
>>> match.groups()
	('Hello', 'world')
>>> match.span()
	(0, 11)

For every element in the iterator, we get a MatchObject, so we can see the captured
groups  also get the position of the match.
>>> match = it.next()
>>> match.groups()
	('hola', 'mundo')
>>> match.span()
	(12, 22)
5> split: In this case, the string is split based on the matches of the pattern.
--------------------------------------------------------------
>>> pattern = re.compile(r"\W")
>>> pattern.split("hello⇢world")
['Hello', 'world']
In the preceding example, we've defined a pattern to match any non-alphanumeric
character. 

The maxsplit parameter specifies how many splits can be done at maximum and
returns the remaining part in the result:
>>> pattern = re.compile(r"\W")
>>> pattern.split("Beautiful is better than ugly", 2)
['Beautiful', 'is', 'better than ugly']

6. sub(repl, string, count=0):returns the resulting string after replacing the matched pattern
------------------------------------------------------------------
>>> pattern = re.compile(r"[0-9]+")
>>> pattern.sub("-", "order0⇢order1⇢order13")
'order-⇢order-⇢order-'
Basically, the regex matches 1 and more digits and replaces the pattern matched, 0, 1,
and 13 here, with - (dash).

Now replace two types in a statement 
Ex: the ones starting with a dash should start with an A and the rest should start with a B.
>>>def normalize_orders(matchobj):
	if matchobj.group(1) == '-': 
		return "A"
	else: 
		return "B"
>>> re.sub('([-|A-Z])', normalize_orders, '-1234⇢A193⇢ B123')
'A1234⇢B193⇢B123'

Ex  :
>>> pattern = re.compile(r'\*(.*?)\*')
>>> pattern.sub(r"<b>\g<1>1<\\b>", text)
'imagine⇢a⇢new⇢<b>world1<\\b>,⇢a⇢magic⇢<b>world1<\\b>'

group :group operation gives you the subgroups of the match
---------------------------------------------------------------
>>> pattern = re.compile(r"(\w+) (\w+)")
>>> match = pattern.search("Hello⇢world")

With group1 bigger than 0, it returns the corresponding group.
>>> match.group(1)
	'Hello'
>>> match.group(2)
	'world'
the pattern has named groups, they can be accessed using the
names or the index:
>>> pattern = re.compile(r"(?P<first>\w+) (?P<second>\w+)")

groups: 
---------------------------------------------------------------

>>> pattern = re.compile("(\w+) (\w+)?")
>>> match = pattern.search("Hello⇢")
>>> match.groups("mundo")
('Hello', 'mundo')
>>> match.groups()
('Hello', None)
The pattern in the preceding example is trying to match two groups made of one or
more alphanumeric characters.

escape()
---------------------------------------------------------------
It escapes the literals that may appear in the expressions.
>>> re.findall(re.escape("^"), "^like^")
['^', '^']
purge()
It purges the regular expressions cache.

Unicode:
----------------------
When you're using Python 2.x and you want to match Unicode, the regex has to be
Unicode escape. For example:
>>> re.findall(r"\u03a9", u"adeΩa")
[]
>>> re.findall(ur"\u03a9", u"adeΩa")
[u'\u03a9']
Note that if you use Unicode characters but the type of the string you're using
is not Unicode, python automatically encodes it using the default encoding.
For example, in my case I have UTF-8:
>>> u"Ω".encode("utf-8")
'\xce\xa9'
>>> "Ω"
'\xce\xa9'
So, you have to be careful while mixing types:
>>> re.findall(r'Ω', "adeΩa")
['\xce\xa9']
-----------------------------------------------------------------------------------------
Type Prefixed Description
String They are string literals. They're Unicode. The backslash is
necessary to escape meaningful characters.
>>>"España \n"
'España \n'
Raw
string
r or R They're equal to literal strings with the exception of the
backslashes, which are treated as normal characters.
>>>r"España \n"
'España \\n'
Byte
strings
b or B Strings represented as bytes. They can only contain ASCII
characters; if the byte is greater than 128, it must be escaped.
>>> b"Espa\xc3\xb1a \n"
b'Espa\xc3\xb1a \n'
We can convert to Unicode in this way:
>>> str(b"Espa\xc3\xb1a \n", "utf-8")
'España \n'
The backslash is necessary to escape meaningful characters.
Byte raw
string
r or R They are like byte strings, but the backslashes are escaped.
>>> br"Espa\xc3\xb1a \n"
b'Espa\\xc3\\xb1a \\n'
So, the backslash used to escape bytes are escaped again,
which complicates their conversion to Unicode:
>>> str(br"Espa\xc3\xb1a \n", "utf-8")
'Espa\\xc3\\xb1a \\n'
Unicode r or U The u prefix was removed in the early versions of Python
3, and recovered in version 3.3 the syntax is accepted again.
They're equal to strings.
------------------------------------------------------------------------------------
import re

The \w = [a-zA-Z0-9_] // All alpha neumeric stuffs and Underline


a = 'My name is ShankarDD  12'

1) Search any 2 any chars after Shankar.

re.search('Shankar\w\w',a).group()  or re.search('Shankar[a-zA-Z0-9_]
													[a-zA-Z0-9_]',a).group()

>> ShankarDD

For any digits use the \d symbol 



2) Match a symbol at the end ^/start $ of a word
re.search('Shankar[^a-zA-Z0-9_][^a-zA-Z0-9_]',a).group()
>> ShankarDD


3) // is used to match a /


4) Finding a email ID :

str = abc@google.com
	match = re.search('([\w.-]+)@([\w.-]+)', str)


\w is match for [^a-zA-Z0-9_]
. - is also added to the email usernme search

So the () @ () will devide the search in 2 groups divided b


So the ([\w.-]+) wil separate the user name with domain 

match.group(1)= abc
match.group(2)= google.com

--------------------------------------------------------------------------------------------|
Method/Attribute|     Purpose								    |
group()		|	Return the string matched by the RE				    |
start()		|	Return the starting position of the match			    |
end()		|	Return the ending position of the match				    |
span()		|	Return a tuple containing the (start, end) positions of the match   |
--------------------------------------------------------------------------------------------|


5)  Group match :


ating White Spaces from a Line Groupp search by Split or by find all:

line = 'test is all done '

pattern_space = re.split("(?:(?:[^a-zA-Z]+')|(?:'[^a-zA-Z]+))|(?:[^a-zA-Z']+)", line)
pattern_space = re.compile("([\w][\w]*'?\w?)").findall(line)


find all will return you a tuples of all  the matching componenst


Ex:
 p = re.compile('\d+')
 p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']


The difference between ?= and ?! is that the former requires the given expression to match and the latter requires it to not match. For example a(?=b) will match the "a" in "ab", but not the "a" in "ac". Whereas a(?!b) will match the "a" in "ac", but not the "a" in "ab".

The difference between ?: and ?= is that ?= excludes the expression from the entire match while ?: just doesn't create a capturing group. So for example a(?:b) will match the "ab" in "abc", while a(?=b) will only match the "a" in "abc". a(b) would match the "ab" in "abc" and create a capture containing the "b".
Split :
----------
Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text 
f all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at
most maxsplit splits occur, and the remainder of the string is returned as the final element of the list


Matching Versus Searching
--------------------------------------------------
Python offers two different primitive operations based on regular expressions: match checks for a
 match only at the beginning of the string,
 while search checks for a match anywhere in the string (this is what Perl does by default).

Example
#!/usr/bin/python
import re

line = "Cats are smarter than dogs";

matchObj = re.match( r'dogs', line, re.M|re.I)
if matchObj:
   print "match --> matchObj.group() : ", matchObj.group()
else:
   print "No match!!"

searchObj = re.search( r'dogs', line, re.M|re.I)
if searchObj:
   print "search --> searchObj.group() : ", searchObj.group()
else:
   print "Nothing found!!"
When the above code is executed, it produces the following result −

No match!!
search --> matchObj.group() :  dogs

Search and Replace:
------------------------------------------------------------
#!/usr/bin/python
import re

phone = "2004-959-559 # This is Phone Number"

# Delete Python-style When the above code is executed, it produces the following result −

Phone Num :  2004-959-559
Phone Num :  2004959559



comments
num = re.sub(r'#.*$', "", phone)
print "Phone Num : ", num

# Remove anything other than digits
num = re.sub(r'\D', "", phone)    
print "Phone Num : ", num



When the above code is executed, it produces the following result −

Phone Num :  2004-959-559
Phone Num :  2004959559

Modifier	Description
re.I	Performs case-insensitive matching.
re.L	Interprets words according to the current locale. This interpretation affects the alphabetic group (\w and \W), as well as word boundary behavior (\b and \B).
re.M	Makes $ match the end of a line (not just the end of the string) and makes ^ match the start of any line (not just the start of the string).


Pattern	Description
^	Matches beginning of line.
$	Matches end of line.
.	Matches any single character except newline. Using m option allows it to match newline as well.
[...]	Matches any single character in brackets.
[^...]	Matches any single character not in brackets

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                          4.  Utility Modules                                                      +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Itertools Module
================================================================================
When iterators were added in Python, a new module was provided to implement
common patterns.

1) islice: 
------------------
One can use islice every time to extract data located in a particular position in a
stream.

itertools.islice(iterable, start, stop[, step])
# islice('ABCDEFG', 2) --> A B
# islice('ABCDEFG', 2, 4) --> C D
# islice('ABCDEFG', 2, None) --> C D E F G
# islice('ABCDEFG', 0, None, 2) --> A C E G

Practicle uses:
This can be a file in a special format using records for instance, or a stream
that presents data encapsulated with metadata, like a SOAP envelope, for example.
In that case, islice can be seen as a window that slides over each line of data

2) tee:
--------------------
An iterator consumes the sequence it works with. There is no turning back. tee
provides a pattern to run several iterators over a sequence. This helps us to run over
the data again, if provided with the information of the first run

 import itertools
 def with_head(iterable, headsize=1):
    a, b = itertools.tee(iterable)
    return list(itertools.islice(a, headsize)), b
   
 with_head(seq)
([1], <itertools.tee object at 0x100c698>)
 with_head(seq, 4)
([1, 2, 3, 4], <itertools.tee object at 0x100c670>)
In this function, if two iterators are generated with tee, then the first one is used
with islice to get the first headsize elements of the iteration, and return them as
a flat list. The second element returned is a fresh iterator that can be used to perform
work over the whole sequence.

3) groupby: The uniq Iterator
------------------------------------
 It is able to group the duplicate elements from an iterator, as long as they are adjacent. A function can
be given to the function for it to compare the elements
Just a few lines are necessary with groupby to obtain RLE:
 from itertools import groupby
 def compress(data):
    return ((len(list(group)), name)
    for name, group in groupby(data))
   
 def decompress(data):
    return (car * size for size, car in data)
   
 list(compress('get uuuuuuuuuuuuuuuuuup'))
[(1, 'g'), (1, 'e'), (1, 't'), (1, ' '),
(18, 'u'), (1, 'p')]
 compressed = compress('get uuuuuuuuuuuuuuuuuup')
 ''.join(decompress(compressed))
'get uuuuuuuuuuuuuuuuuup

These function are used to make utilities for a ode libarary 
 # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
 # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
 
Others are:
------------------------------
Infinite Iterators:
# count(10) --> 10 11 12 13 14    
# count(2.5, 0.5) -> 2.5 3.0 3.5    
# cycle('ABCD') --> A B C D A B C D A B C D    
# repeat(10, 3) --> 10 10 10
Iterators terminating on the shortest input sequence:
# chain('ABC', 'DEF') --> A B C D E F
# compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F
#ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9
# imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000   (2P5,)
# izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
Combinatoric generators:
# product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
# product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
# permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
# permutations(range(3)) --> 012 021 102 120 201 210
# combinations('ABCD', 2) --> AB AC AD BC BD CD
# combinations(range(4), 3) --> 012 013 023 123


functools Module
================================================================================
How do you make a higher order function in Python?
Functions and methods are first-class objects in Python, so if you want to pass a function to another function,
 you can just treat it as any other object.

To bind a function object to a specific context, you can use either nested scopes or callable objects.
For example, suppose you wanted to define linear(a,b) which returns a function f(x) that computes the value a*x+b.
Using nested scopes:

def linear(a, b):
    def result(x):
        return a*x + b
    return result
Or using a callable object:

class linear:
   def __init__(self, a, b):
       self.a, self.b = a,b
   def __call__(self, x):
       return self.a * x + self.b
In both cases:

taxes = linear(0.3, 2)
gives a callable object where taxes(10e6) == 0.3 * 10e6 + 2.

The callable object approach has the disadvantage that it is a bit slower and results in slightly longer code.
 It can be a bit easier to understand, though, especially if you’re used to OO design. 
The functools module 
The functools module is for higher-order functions: functions that act on or return other functions. In general,
any callable object can be treated as a function for the purposes of this module.

The functools module is for higher-order functions: functions that act on or return other functions. 
In general, any callable object can be treated as a function for the purposes of this module.
1> functools.cmp_to_key(func)
old-style comparison function to a key function 
Example:

sorted(iterable,key=functools.cmp_to_key(mycomp))
 def mycmp(a, b):
...     print("In Mycmp for", a, ' ', b)
...     if a < b:
...         return -1
...     elif a > b:
...         return 1
...     return 0
uses:

Used with tools that accept key functions (such as sorted(), min(), max(), heapq.nlargest(), heapq.nsmallest(), 
itertools.groupby()). This function is primarily used as a transition tool for programs being converted from Python 2 
which supported the use of comparison functions.

2> @functools.lru_cache(maxsize=128, typed=False)

A decorator memoizing callable that saves up to the maxsize most recent calls. It can save time when an expensive 
or I/O bound function is periodically called with the same arguments.

Since a dictionary is used to cache results, the positional and keyword arguments to the function must be hashable.

So it will directly list you the output if the key is called before once this is done 
@lru_cache(maxsize=32)
def get_pep(num):
    'Retrieve text of a Python Enhancement Proposal'
    resource = 'http://www.python.org/dev/peps/pep-%04d/' % num
    try:
        with urllib.request.urlopen(resource) as s:
            return s.read()
    except urllib.error.HTTPError:
        return 'Not Found'

>>> for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:
...     pep = get_pep(n)
...     print(n, len(pep))

>>> get_pep.cache_info()
CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)
Here the cache is used for 3 hits i,e 3 times a previous key is been called in the 
list and 8 times it has been missed 

3) Wraps
---------------
Basic decorator:

from functools import wraps

def my_decorator(view_func):
    def _decorator(request, *args, **kwargs):
        # maybe do something before the view_func call
        response = view_func(request, *args, **kwargs)
        # maybe do something after the view_func call
        return response
    return wraps(view_func)(_decorator)

# how to use it...
def foo(request): return HttpResponse('...')
foo = my_decorator(foo)

# or...
@my_decorator
def foo(request): return HttpResponse('...')
(the wraps function is explained below)

Parameterized decorator:

This one allows you to pass arguments into the decorator for some additional customization. It needs to wrap everything in an additional function (creating a closure) in order to make this possible.

from functools import wraps

def my_decorator(extra_value=None):
    def _my_decorator(view_func):
        def _decorator(request, *args, **kwargs):
            # maybe do something before the view_func call
            # that uses `extra_value` and the `request` object
            response = view_func(request, *args, **kwargs)
            # maybe do something after the view_func call
            return response
        return wraps(view_func)(_decorator)
    return _my_decorator

# how to use it...
def foo(request): return HttpResponse('...')
foo = my_decorator('some-custom-value')(foo)

# or...
@my_decorator('some-custom-value')
def foo(request): return HttpResponse('...')
A class decorator:

from functools import wraps

class my_decorator(object):

    def __init__(self, view_func):
        self.view_func = view_func
        wraps(view_func)(self)

    def __call__(self, request, *args, **kwargs):
        # maybe do something before the view_func call
        response = self.view_func(request, *args, **kwargs)
        # maybe do something after the view_func call
        return response

# how to use it...
def foo(request): return HttpResponse('...')
foo = my_decorator(foo)

# or...
@my_decorator
def foo(request): return HttpResponse('...')

5) partial:
Partial Function Application:

If you read through the source code for wraps in functools, then you saw that it uses the partial function.
 Partial is awesome—it’s sort of like currying. It lets you create a new function from an existing function 
 with some of the arguments predefined. Here’s a relatively trivial example that makes a new min function 
 by setting its “key” argument to be absolute value:

from functools import partial
min_abs_val = functools.partial(min, key=abs)
min_abs_val(-5, -1, 2) == -1
You can see it in action in the functools source code, but if you’d prefer a convoluted explanation of how
 it’s used… you can see that the wraps function is a decorator that is cleverly using the partial function 
 to return a partial function of the update_wrapper function, which now only needs the wrapper function argument,
 and that argument will be the function that is decorated inside of a decorator function that will eventually wrap
 other functions… INCEPTION


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                        5.   Debugging Modules                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Debugging in python:
=========================

PDB:

You can use the pdb module, insert pdb.set_trace() anywhere and it will function as a breakpoint.

>>> import pdb
>>> a="a string"
>>> pdb.set_trace()
--Return--
> <stdin>(1)<module>()->None
(Pdb) p a
'a string'
(Pdb)
To continue execution use c (or cont or continue).
It is possible to execute arbitrary Python expressions using pdb. For example, if you find a mistake, you can correct the code, 
then type a type expression to have the same effect in the running code .

PUDB:

python -m pudb.run my-script.py

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                     6.  Unit test Modules                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Testing the Python Modules :
------------------------------------------
The standard workflow is:[unit_test_200.py]
1. You define your own class derived from unittest.TestCase.
2. Then you fill it with functions that start with ‘test_’.
3. You run the tests by placing unittest.main() in your file, usually at the bottom.

One of the many benifits of unittest, that you’ll use when your tests get bigger than the toy examples I’m showing on this blog,
 is the use of ‘setUp’ and ‘tearDown’ functions to get your system ready for the tests.

Like the doctest introduction, I’ll run through a simple example first, then show how I’m using unittest for testing markdown.py.

unittest example  [unit_test_200.py]

class Tests(unittest.TestCase):
    def setUp(self):
        print('Gonna Run the test cases')
	def tearDown(self):
        print('Over test cases')
    def runTest3(self):
        print('test1')
        self.assertEqual({'acad'},lcs('academy', 'abracadabra'))
    def runTest2(self):
        print('test2')
        self.assertEqual({'abc','aba'},lcs('ababc', 'abcdaba'))
	
	
    @unittest.skipUnless(sys.platform.startswith("win"), "requires Windows")
    def test_windows_support(self):
        # windows specific testing code
        pass

 



def suite():
    test_suite = unittest.TestSuite()
    test_suite.addTest(Tests('runTest2'))
    test_suite.addTest(Tests('runTest3'))
	test_suite.addTest(Tests('test_windows_support'))
    return test_suite



if __name__ == "__main__":

   unittest.TextTestRunner(verbosity=2).run(suite())
The output of the above is 
Gonna Run the test cases
runTest2 (__main__.Tests) ... ok
test2
runTest3 (__main__.Tests) ... ok
test_windows_support (__main__.Tests) ... skipped 'requires Windows'

----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK (skipped=1)
Gonna Run the test cases
test2
Over test cases
Gonna Run the test cases
test1
Over test cases

nose : Python testing framework 
-----------------------------------


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                         7.  File parsing Modules                                                  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                       8.  Gui Modules                                                      		  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Tkinter:[Mod_tkinter_200.py]
PyQt:[Pyqt_300.py]
	

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                       9.    Database Modules (ORM)                                                     +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power

Python classes <---> Database tables 
classes (objects) <--->  rows in the corresponding tables {Declarative}

 SQLAlchemy, this is done by creating an SQLEngine object, which knows how to talk to one particular type of database 
 (SQLite, PostgreSQL, Firebird, MySQL, Oracle...).
  it will create a pool of database connections and re-use them automatically as needed, to keep your application 
  running quickly.
  
  



Declarative : 
--------------
It allows us to create classes that include directives to describe the actual database table they will be mapped to

Declarative base class.
------------------------
catalog of classes and tables relative to that base, Each module using Declarative have only one instance 




The Django ORM and flexibility of SQL


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                       10.    Web Server  Modules                                                   +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Tornado (Python web framework and asynchronous networking library)


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                         11.  Event based Modules                                                   +                
+                                                                                                                 +
+                                                                                                                 +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
gevent is a coroutine-based Python networking library


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                          12. OS handling Modules                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[Sel_copy_200.py]
import os

os.environ['saikat'] = '/local/saikatsa/python'] <---this creates an environment variable named as saikat
Print os.environ['saikat'] <--- this gives environment variable printed
os.getenv('env name') <---this gives given environment variable value 
os.putenv('env name', 'value') <---this actually sets env value
os.environ.pop('env variable name') <---this deletes env variable

os.getlogin() <--- this gives login name
os.getcwd() <--- this gives current working directory
Os.chdir('..') <--- this changes the directory e.g. here it goes one level up
os.uname() <--- gives OS/Processor information

os.access('filename', os.R_OK) <--- this returns True if Read access is available else False
os.access('filename', os.F_OK) <---this returns true if filename/path is correct/exists otherwise False
os.access('filename', os.W_OK) <---this returns True if write access persists otherwise false
os.access('filename', os.X_OK) <---this returns true if filename is executable otherwise false

os.listdir('/local/saikatsa')  <---this gives filename, directory name as a list in the given path
os.walk() <--- it returns a generator which shall give same as listdir while doing next operator

os.rename('temp.cc','temp1.cc') <--- this renames file temp.cc to temp1.cc. Also it renames the directory
os.renames('directory_names', 'new name') <--- this renames directory name
os.remove('filename') <--- it removes a file
os.removedirs('directory') <--- it removes empty directory

os.abort() <--- closes the program
os.system('linux command') <--- it executes linux commands

os.path.abspath('.') <--- this gives absolute path of current directory e.g. /local/saikatsa/python
os.path.exists('/home/saikatsa') <--- this returns true if path exist otherwise false same as os.access('path', os.F_OK)
os.path.isfile('name') <--- returns true if name is a file
os.path.isdir('name') <--- returns true if name is a directory
os.path.isabs('path name')  <---- returns true if given path is absolute one.



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                       13.   Web Scarping  Modules                                                  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

urlib: [website_crawler_urllib_200.py],[website_crawler_200.py]
Mechanize:(very useful python module for navigating through web forms )
--------------------------------------------------------------------------
Scrapy: (involved in webscraping then this is a must )

To install scarpy i have tested for a 64 bit ubuntu 
1) sudo apt-get install build-essential libssl-dev libffi-dev python-dev
2) sudo apt install scrapy 



beautifulsoup:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                     14.     DataAnalytics Modules                                                  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Panda
providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                     15.     Automation Modules                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                       16.    Protocol Modules                                                      +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                       17.    Threading Modules                                                      +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
[threading_test_200.py]
