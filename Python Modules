+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                           String parsing Modules                                                +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Strings:
======================================




Reg Expresions:
======================================
import re

The \w = [a-zA-Z0-9_] // All alpha neumeric stuffs and Underline


a = 'My name is ShankarDD  12'

1) Search any 2 any chars after Shankar.

re.search('Shankar\w\w',a).group()  or re.search('Shankar[a-zA-Z0-9_][a-zA-Z0-9_]',a).group()

>> ShankarDD

For any digits use the \d symbol 



2) Match a symbol at the end ^/start $ of a word
re.search('Shankar[^a-zA-Z0-9_][^a-zA-Z0-9_]',a).group()
>> ShankarDD


3) // is used to match a /


4) Finding a email ID :

str = abc@google.com
	match = re.search('([\w.-]+)@([\w.-]+)', str)


\w is match for [^a-zA-Z0-9_]
. - is also added to the email usernme search

So the () @ () will devide the search in 2 groups divided b


So the ([\w.-]+) wil separate the user name with domain 

match.group(1)= abc
match.group(2)= google.com

--------------------------------------------------------------------------------------------|
Method/Attribute|     Purpose								    |
group()		|	Return the string matched by the RE				    |
start()		|	Return the starting position of the match			    |
end()		|	Return the ending position of the match				    |
span()		|	Return a tuple containing the (start, end) positions of the match   |
--------------------------------------------------------------------------------------------|


5)  Group match :


ating White Spaces from a Line Groupp search by Split or by find all:

line = 'test is all done '

pattern_space = re.split("(?:(?:[^a-zA-Z]+')|(?:'[^a-zA-Z]+))|(?:[^a-zA-Z']+)", line)
pattern_space = re.compile("([\w][\w]*'?\w?)").findall(line)


find all will return you a tuples of all  the matching componenst


Ex:
 p = re.compile('\d+')
 p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']


The difference between ?= and ?! is that the former requires the given expression to match and the latter requires it to not match. For example a(?=b) will match the "a" in "ab", but not the "a" in "ac". Whereas a(?!b) will match the "a" in "ac", but not the "a" in "ab".

The difference between ?: and ?= is that ?= excludes the expression from the entire match while ?: just doesn't create a capturing group. So for example a(?:b) will match the "ab" in "abc", while a(?=b) will only match the "a" in "abc". a(b) would match the "ab" in "abc" and create a capture containing the "b".
Split :
----------
Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text 
f all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at
most maxsplit splits occur, and the remainder of the string is returned as the final element of the list


Matching Versus Searching
--------------------------------------------------
Python offers two different primitive operations based on regular expressions: match checks for a match only at the beginning of the string,
 while search checks for a match anywhere in the string (this is what Perl does by default).

Example
#!/usr/bin/python
import re

line = "Cats are smarter than dogs";

matchObj = re.match( r'dogs', line, re.M|re.I)
if matchObj:
   print "match --> matchObj.group() : ", matchObj.group()
else:
   print "No match!!"

searchObj = re.search( r'dogs', line, re.M|re.I)
if searchObj:
   print "search --> searchObj.group() : ", searchObj.group()
else:
   print "Nothing found!!"
When the above code is executed, it produces the following result −

No match!!
search --> matchObj.group() :  dogs

Search and Replace:
------------------------------------------------------------
#!/usr/bin/python
import re

phone = "2004-959-559 # This is Phone Number"

# Delete Python-styleWhen the above code is executed, it produces the following result −

Phone Num :  2004-959-559
Phone Num :  2004959559



comments
num = re.sub(r'#.*$', "", phone)
print "Phone Num : ", num

# Remove anything other than digits
num = re.sub(r'\D', "", phone)    
print "Phone Num : ", num



When the above code is executed, it produces the following result −

Phone Num :  2004-959-559
Phone Num :  2004959559

Modifier	Description
re.I	Performs case-insensitive matching.
re.L	Interprets words according to the current locale. This interpretation affects the alphabetic group (\w and \W), as well as word boundary behavior (\b and \B).
re.M	Makes $ match the end of a line (not just the end of the string) and makes ^ match the start of any line (not just the start of the string).


Pattern	Description
^	Matches beginning of line.
$	Matches end of line.
.	Matches any single character except newline. Using m option allows it to match newline as well.
[...]	Matches any single character in brackets.
[^...]	Matches any single character not in brackets


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                           OS handling Modules                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++





+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                           Utility Modules                                                      +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Itertools Module
================================================================================
When iterators were added in Python, a new module was provided to implement
common patterns.

1) islice: 
------------------
One can use islice every time to extract data located in a particular position in a
stream.

itertools.islice(iterable, start, stop[, step])
# islice('ABCDEFG', 2) --> A B
# islice('ABCDEFG', 2, 4) --> C D
# islice('ABCDEFG', 2, None) --> C D E F G
# islice('ABCDEFG', 0, None, 2) --> A C E G

Practicle uses:
This can be a file in a special format using records for instance, or a stream
that presents data encapsulated with metadata, like a SOAP envelope, for example.
In that case, islice can be seen as a window that slides over each line of data

2) tee:
--------------------
An iterator consumes the sequence it works with. There is no turning back. tee
provides a pattern to run several iterators over a sequence. This helps us to run over
the data again, if provided with the information of the first run

 import itertools
 def with_head(iterable, headsize=1):
    a, b = itertools.tee(iterable)
    return list(itertools.islice(a, headsize)), b
   
 with_head(seq)
([1], <itertools.tee object at 0x100c698>)
 with_head(seq, 4)
([1, 2, 3, 4], <itertools.tee object at 0x100c670>)
In this function, if two iterators are generated with tee, then the first one is used
with islice to get the first headsize elements of the iteration, and return them as
a flat list. The second element returned is a fresh iterator that can be used to perform
work over the whole sequence.

3) groupby: The uniq Iterator
------------------------------------
 It is able to group the duplicate elements from an iterator, as long as they are adjacent. A function can
be given to the function for it to compare the elements
Just a few lines are necessary with groupby to obtain RLE:
 from itertools import groupby
 def compress(data):
    return ((len(list(group)), name)
    for name, group in groupby(data))
   
 def decompress(data):
    return (car * size for size, car in data)
   
 list(compress('get uuuuuuuuuuuuuuuuuup'))
[(1, 'g'), (1, 'e'), (1, 't'), (1, ' '),
(18, 'u'), (1, 'p')]
 compressed = compress('get uuuuuuuuuuuuuuuuuup')
 ''.join(decompress(compressed))
'get uuuuuuuuuuuuuuuuuup

These function are used to make utilities for a ode libarary 
 # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
 # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
 
Others are:
------------------------------
Infinite Iterators:
# count(10) --> 10 11 12 13 14    
# count(2.5, 0.5) -> 2.5 3.0 3.5    
# cycle('ABCD') --> A B C D A B C D A B C D    
# repeat(10, 3) --> 10 10 10
Iterators terminating on the shortest input sequence:
# chain('ABC', 'DEF') --> A B C D E F
# compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F
#ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9
# imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000   (2P5,)
# izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
Combinatoric generators:
# product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
# product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
# permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
# permutations(range(3)) --> 012 021 102 120 201 210
# combinations('ABCD', 2) --> AB AC AD BC BD CD
# combinations(range(4), 3) --> 012 013 023 123


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                           Debugging Modules                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Debugging in python:
=========================

PDB:

You can use the pdb module, insert pdb.set_trace() anywhere and it will function as a breakpoint.

>>> import pdb
>>> a="a string"
>>> pdb.set_trace()
--Return--
> <stdin>(1)<module>()->None
(Pdb) p a
'a string'
(Pdb)
To continue execution use c (or cont or continue).
It is possible to execute arbitrary Python expressions using pdb. For example, if you find a mistake, you can correct the code, 
then type a type expression to have the same effect in the running code .

PUDB:

python -m pudb.run my-script.py

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                           Unit test Modules                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Testing the Python Modules :
------------------------------------------
The standard workflow is:
1. You define your own class derived from unittest.TestCase.
2. Then you fill it with functions that start with ‘test_’.
3. You run the tests by placing unittest.main() in your file, usually at the bottom.

One of the many benifits of unittest, that you’ll use when your tests get bigger than the toy examples I’m showing on this blog,
 is the use of ‘setUp’ and ‘tearDown’ functions to get your system ready for the tests.

Like the doctest introduction, I’ll run through a simple example first, then show how I’m using unittest for testing markdown.py.

unittest example

Using the same unnecessary_math.py module that I wrote in the
doctest intro, here’s some example test
code to test my ‘multiply’ function.

test_um_unittest.py:

 
import unittest
from unnecessary_math import multiply

class TestUM(unittest.TestCase):

    def setUp(self):
        pass

    def test_numbers_3_4(self):
        self.assertEqual( multiply(3,4), 12)

    def test_strings_a_3(self):
        self.assertEqual( multiply('a',3), 'aaa')

if __name__ == '__main__':
    unittest.main()



In this example, I’ve used assertEqual(). The unittest framework has a whole bunch of assertBlah() style functions like assertEqual().
 Once you have a reasonable reference for all of the assert functions bookmarked, working with unnittest is pretty powerful and easy.

Aside from the tests you write, most of what you need to do can be accomplished with the test fixture methods such as setUp, tearDown,
 setUpClass, tearDownClass, etc.

Running unittests

At the bottom of the test file, we have this code:


 
if __name__ == '__main__':
    unittest.main()
This allows us to run all of the test code just by running the file.
Running it with no options is the most terse, and running with a ‘-v’ is more verbose, showing which tests
ran.



> python test_um_unittest.py
..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
> python test_um_unittest.py -v
test_numbers_3_4 (__main__.TestUM) ... ok
test_strings_a_3 (__main__.TestUM) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.000s
OK





+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                           File parsing Modules                                                  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++





+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                           Database Modules                                                      +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                          Automation Modules                                                	  +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                                                                                                                 +
+                                           Protocol Modules                                                      +                
+                                                                                                                 +
+                                                                                                                 +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
