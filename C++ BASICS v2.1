

1) For  Putting two classs with the same name and using it 


namespace Records {
const int kDefaultStartingSalary = 30000;
class Employee
{
    public:
        Employee();
        void     promote(int inRaiseAmount = 1000);
        void     demote(int inDemeritAmount = 1000);
        void     hire();     // Hires or rehires the employee
        void     fire();     // Dismisses the employee
        void     display();
	
   private:
       int         mSalary;
       bool        fHired;
};

//Use of the nmaespace 
using namespace Records;
Employee emp;
emp.setFirstName( Marni );
///////////////////////////////////////////////////////////////////////////////////////
Name Hiding 
///////////////////////////////////////////////////////////
So, what should be done here?

Functions in derived classes with the same name as the functions in the parent classes, but that do not override the parent
classes’ function are considered to be bad practice because it can result in errors just like the one above. So, having a
function like someFunction above is considered to be bad practice. This is technically not method overloading either,
because overloading functions is done within the same class – not in an inheritance hierarchy.

The reason it’s bad practice is because it leads to ambiguity, and it’s much easier to just give the functions different
names instead.

Understanding the error message you would get with name hiding

So, why does the code above result in that error message? Actually, the name lookup that is run by C++ will stop looking
for other names as soon as it finds a single name in one of your base classes. This is because the someFunction declaration
in ChildClass actually hides the someFunction declaration in ParentClass – so when a call to someFunction is made from
GrandChildClass, the name lookup does not “see” the someFunction declaration that is in the ParentClass. But, there is
another interesting “solution” to name hiding. It’s more of a way to override the name hiding behavior if you need to,
because we can’t really say that name hiding is a “problem” since it’s intention is really to prevent other problems in C++.
So, our “solution” is to unhide the someFunction declaration in ChildClass – read below for more details on how to do this.

Name hiding and using

We can actually provide a solution to the name hiding problem in the example above. All we have to do is implement the
using keyword. Here is how to do it:

class ParentClass
{
    public:
    void someFunction(string s){ };
};

class ChildClass : public ParentClass
{
    public:
    int someFunction(int i){};

    /*This makes the someFunction
       declaration in ParentClass visible
       here as well:
    */
    using ParentClass::someFunction;
};

class GrandChildClass : public ChildClass
{
    public:
    void differentFunction()
    {
        String s;
        /*This call will result in an error:  */
        someFunction(s); 

    }
};

When we redeclare someFunction in the scope of ChildClass (with the “using” keyword), it makes both versions of that
function (from both ChildClass and GrandChildClass) visible in just the ChildClass.

Why does C++ have the concept of name hiding?

There is actually a good reason why C++ has name hiding. Consider the example below:

class ParentClass
{
    public:
    void someFunction(string s){ };
};

class ChildClass : public ParentClass
{
    public:
    int someOtherFunction(int i){};

    /*This will use the same version of someFunction
       that is in the ParentClass, since it does not have
       it's own definition of someFunction
    */
};

class GrandChildClass : public ChildClass
{
   /* This overrides someFunction, creating
       a new version */
    public:
    float someFunction(float i){};
 
};
What if there was no concept of name hiding in C++?

Let’s suppose that there was no name hiding. Then this means that in the GrandChildClass, both versions of someFunction are now visible including the one in the parent class ParentClass – so float someFunction(float i), and void someFunction(string s) are both visible in the GrandChildClass class. If a call to “someFunction(29)” is made in either the ChildClass or the ParentClass, then it would obviously use the “void someFunction(string s){ };” version of the function since that is the only version of the function that those classes can “see”.

However, in the GrandChildClass if a call to “someFunction(29)” is made then there are 2 different functions that are visible – both someFunction(float i) and someFunction(string s) . It will obviously use someFunction(float i) since that is a better match for the parameter of 29. But, the issue here is that in the entire hierarchy of classes, the version of someFunction that is used is typically someFunction(string s), but once we get to the GrandChildClass, a different version of the someFunction function is used. This type of behavior was then considered to be undesirable by the C++ standard writers, so they implemented name hiding, which effectively gives each class a “clean slate” or a new, clean class that does not carry over the scope of inherited functions with the same name.






CHAP2:  Designing Professional  C++ Programs
**************************************************
include class hierarchies, class interfaces, and object interactions. C++ is its numerous facilities for designing 
generic and reusable code.In addition to basic classes and inheritance,

Polymorphism :Polymorphism is a beautiful part of object-oriented programming because it truly takes advantage of
what inheritance offers. In a zoo simulation, we could programmatically loop through all of the animals
in the zoo and have each animal move once. Since all animals are members of the Animal class, they all
know how to move. Some of the animals have overridden the move behavior, but that s the best part â€”
our code simply tells each animal to move without knowing or caring what type of animal it is. Each one
moves whichever way it knows how.

2) has a =  base class has a obj of another type
  Is a = monekey is a Animal (Inheritance)
  
  
  
  
  C++ virtual inheritance is implemented in compilers?


How the compilers implement the virtual inheritance?

In the following code:

class A {
  public:
    A(int) {}
};

class B : public virtual A {
  public:
    B() : A(1) {}
};

class C : public B {
  public:
    C() : A(3), B() {}
}
Compiler code generation

B1()
B2() // no A
When B is constructed, the "full" version is called:

B1():
    A(1)
    B() body
When C is constructed, the base version is called instead:

C():
    A(3)
    B2()
       B() body
    C() body
In fact, two constructors will be emitted even if there is no virtual inheritance, and they will be identical.
 
 ///////////////////////////////////////////////////////////////
 implement a “private/restricted” function in C
 Here's one way:

int f_real_name(void)
{
    ...
}

#define f f_real_name
int g(void)
{
    // call f()
}
#undef f

// calling f() now won't work
Another way, if you can guarantee that f() and g() are the only functions in the file, is to declare f() as static.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHAP3: Designing with Libraries and Patterns
**************************************************************
Reusing Code : Templats, Libaries 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHAP4: Designing for Reuse
3) Develop Intuitive Interfaces								
Fraction f1(3,4), f2(1,2), sum, diff;
sum = f1 + f2;
diff = f1 - f2;

(Before Intitutive interface)
Fraction f1(3,4), f2(1,2), sum, diff;
sum = f1.add(f2);

Decomposition is the practice of breaking up code into smaller pieces.Ideally, each function or method should accomplish a single task. 
Any subtasks of signifi-cant complexity should be decomposed into separate functions or methods
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Variable and Instance Variable:
Class variables – also known as static member variables

Class variables, however, only have one copy of the variable(s) shared with all instances of the class.
It’s important to remember that class variables are also known as static member variables in C++, Java
, and C#. Each object of the class does not have its own copy of a class variable. Instead, every object shares
the one and only copy of that class variable – and any changes made to that copy are seen by all of the objects 
of that class. Here is what a class variable – or a static member variable – would look like in C++:

Example of a class variable:

class Taxes
{
  static int count;
  /*...*/
}
///////////////////////////////////////

How do you call C functions from C++?
++++====++++++++++++++++++++++++++++++++++
In order to call a C function from C++ code, you would use the “extern “C”” keyword when declaring the function in C.
Then, you would call the function just like you would call any other function. An example will help clarify this:

/*this is what the C++ code would look like
   for the declaration of the foo function, which 
   is defined somewhere else in C code: */

extern "C" void foo( );	

And then to call the function in the C++ code, it would look like this:

//the declaration:
extern "C" void foo();

void main()
{
  // the function call:
  foo( );
}
What if we want to declare multiple C functions at once in our C++ code?

If you have more than one C functions that you would like to call from your C++ code, then it would be best to group 
them and declare them like this:


/* this is inside the C++ code,
     if we want to access multiple C functions
     from C++ then we can declare them like this:
*/
extern "C" {	
  
		int foo( );

		double foobar();
	};	

And then those functions could be called just like we showed above.


CHAP8 : 
4)  Use of this to take its on variable and use 
---------------------------------------------------------------------------------------------
void SpreadsheetCell::setValue(double mValue)
{
    this->mValue = mValue;
    mString = doubleToString(this->mValue);
}

5) 
----------------------------------------------------------------------------- 
class SpreadsheetCell
{
    public:
        SpreadsheetCell();
        SpreadsheetCell(double initialValue);
        SpreadsheetCell(const string& initialValue);
        SpreadsheetCell(const SpreadsheetCell &src);
        SpreadsheetCell& operator=(const SpreadsheetCell& rhs);
        void setValue(double inValue);
        double getValue();
        void setString(const string& inString);
        string getString();
    protected:
        string doubleToString(double inValue);
        double stringToDouble(const string& inString);
        double mValue;
        string mString;
};
SpreadsheetCell(const SpreadsheetCell &src): //copy constructor: list intilisation for reference
{

	if (this == &src)
	 {
  		return (*this);
	 }
		mValue = src.mValue;
		mString = src.mString;
 	 	
}

This format is given by the compliler any deviation with the signature wil result in error.
& = The reference prevents a copy of the Object temp object to be created and the address is received as a
     whole no Value copying.
This format prevents the calling of copy constructor in recurssion in case of a vale is passed .

SpreadsheetCell& SpreadsheetCell::operator=(const SpreadsheetCell& rhs)   //Asignment opersator 
{

	if (this == &rhs)
	 {
  		return (*this);
	 }
		mValue = rhs.mValue;
		mString = rhs.mString;
 	 	return (*this);
}

6) Calling an asignment operator and a copy constructor:
--------------------------------------------------------------------------------------
a copy constructor:
***********************
SpreadsheetCell myCell(5);
SpreadsheetCell anotherCell(myCell);
SpreadsheetCell aThirdCell = myCell;
an asignment operator
***********************
anotherCell = myCell; 
7) Use of Copy constructor:
----------------------------------------------------------------------------------------
a} 
string SpreadsheetCell::getString()
{
    return (mString);
}
string s1;
s1 = myCell2.getString();

The compiler actually creates an unnamed temporary 
object by calling a class copy constructor. When you assign this result to s1, the assignment operator
is called for s1 with the temporary string as a parameter this temporary string Value is copied from Copy Constructor
output value.When the Value is copied by the assiagnment operator then the temporary string object is
destroyed. Thus, the single line of code invokes the copy constructor and the assignment operator (for
two different objects).

string s2 = myCell3.getString();
           getString() still creates a temporary unnamed string object when it returns mString.
But now s1 gets its copy constructor called, not its assignment operator.

So in case 2 temporary objects are being created we can remove it by uisng MoveContructor ,




Move constructors 
======================
Move constructors of classes using dynamic memory allocation are allowed to assign the values of
pointer data members to their own pointer data members without requiring them to make a copy of
the source’s data. Next, the temporary’s pointer value is set to zero to prevent its destructor from
destroying data now owned by the just constructed object. The move constructor has grabbed or
stolen the data from the temporary object. This is OK as the temporary object cannot be referred to
again (as it is anonymous, it cannot be accessed by other code) and the temporary objects cease to
exist shortly after the constructor’s call. Here is the implementation of Strings move constructor:

String::SpreadsheetCell::String(String &&tmp)  // take the temporary object
:
d_memory(std::move(tmp.d_memory))  // Intialise your own memory and size and capacity

{
	tmp.d_memory = 0;  //memory of the temp obj is set as 0
}


a move constructor suppresses the default availability of the copy constructor.
The default copy constructor is also suppressed if a move assignment operator is declared So to restore that 
class Class
{
public:

Class() = default;
Class(Class const &other) = default;
Class(Class &&tmp)
{}


~Class()
{
delete[] d_str;
}
};
int main()
{
Class one;
Class two(one);
}


In C++, what’s the difference between an inline function and a macro?
-------------------------------------------------------------------------

The major difference between inline functions and macros is the way they are handled. Inline functions are parsed by 
the compiler, whereas macros are expanded by the C++ preprocessor. This difference creates other differences, as best
illustrated by examples.



The C++ preprocessor implements macros by using simple text replacement. Suppose we have the following macro:

#define SUM(a,b) (a+b)
When the preprocessor comes across any occurrences of SUM(first, last) in the code, then that text will be replaced by
(first + last). When would one want to use a macro? Usually when what you’re substituting for is very simple, and does
not justify the overhead of a function call. Remember that function calls do incur overhead.

Inline functions, as mentioned earlier, are parsed by the compiler directly instead of the preprocessor. Inline functions
look very similar to regular functions. Here is what an inline function implementation of the SUM macro would look like:

// note the use of the 'inline' keyword

inline int sum(int a, int b)
{
	return (a+b);
}
The difference between an inline function and a regular function is that wherever the compiler finds a call to an inline 
function, it writes a copy of the compiled function definition. However, with a regular function, a normal function call
is generated.
The reason C++ has inline functions and macros is to eliminate the overhead incurred by function calls. However, 
the tradeoff of this is the fact that the program size increases with both macros and inline functions. Remember
that inline functions look like regular functions, but macros are implemented with text replacement.

The fact that macros use text replacement creates the potential for bugs. Suppose we have the following code:

#define DOUBLE(X) X*X

 int y = 3;
 int j = DOUBLE(++y);
If you’re expecting that j will be assigned a value of 4 squared (16), then you would be wrong. Because of the text
replacement, what actually happens is that the DOUBLE(++y) expands to ++y * ++y, which equals 4*5, giving us 20.
This problem would not occur if DOUBLE were implemented as an inline function. Inline functions only evaluate their 
arguments once, so any side effects of evaluation happen only once.

Another problem with macros occurs with binding. Suppose we have a macro with two statements, and then we
try to use that macro with an if statement. If we decide not to use the curly brackets with our if statement, then we
will have something that looks like this:

#define ADD_TWO(x,y) x += 2; y +=2

bool flag = true;
int j = 5, k = 7;


if(flag)
	ADD_TWO(j,k);
Then you’re probably thinking that the macro will expand to this:

if(flag)
{
	j +=2;
	k +=2;	
} 
But what actually happens is that the if statement binds to the first expression in the macro. So this is what it really 
expands to:

if(flag)
{
	j +=2;
} 	
	
k +=2;
If we had used an inline function instead of a macro, the problem shown above would not have occurred. 
This is because an inline function is treated as a single statement, so the entire function would be bound to the if statement.


Debugging macros is also difficult. This is because the preprocessor does the textual replacement for macros, but that textual
replacement is not visible in the source code itself. Because of all this, it’s generally considered a good idea to use inline
functions over macros.

////////////////////////////////////////////////////////////////////
Virtual functions 
////////////////////////////////////////////////////////////////////
A virtual function is a member function of a class, whose functionality can be over-ridden in its derived classes. 
It is one that is declared as virtual in the base class using the virtual keyword. 

What is Binding?
***********************************
Binding refers to the act of associating an object or a class with its member. 
If we can call a method fn() on an object o of a class c, we say that the object o is binded with the method fn().
 This happens at compile time and is known as static or compile - time binding.
The calls to the virtual member functions are resolved during run-time.This mechanism is known as dynamic binding.
The most prominent reason why a virtual function will be used is to have a different functionality in the derived 
class.


How does a Virtual Function work?
****************************************
Whenever a program has a virtual function declared, a v - table is constructed for the class.
 The v-table consists of addresses to the virtual functions for classes that contain .Whenever there is a virtual function call,
 the v-table is used to resolve to the function address. An object of the class that contains one or more virtual functions contains
 a virtual pointer called the vptr at the very beginning of the object in the memory. 
Hence the size of the object in this case increases by the size of the pointer. This vptr contains the base address of the virtual table in memory

run time when a virtual function is called on an object, the vptr of that object provides the base address of the virtual table
for that class in memory. 
This table is used to resolve the function call as it contains the addresses of all the virtual functions of that class. 
This is how dynamic binding is resolved during a virtual function call.


                                                                                when a method is called on
An object, the pointer is followed into the vtable and the appropriate version of the method is executed
based on the type of the object, not the type of the variable used to access it.
k,
EX:
                 Two classes, Super and Sub. Super declares two virtual methods, foo() and bar(). As
you can see by looking at Super s vtable, each method has its own implementation defined by the
Super class. The Sub class does not override Super s version of foo(), so the Sub vtable points to the
same implementation of foo(). Sub does, however, override bar(), so the vtable points to the new
version.


 virtual  table architecture:
****************************************************
The virtual function table actually contains two more entries before the function pointers: 
1>a pointer to a "type ID" structure, a separate structure that describes the class itself,
2>memory offset whose use we'll look at later. So if we have this C++ code:

class foo {
virtual void a(int);    // Virtual functions
virtual void b(float);
int c;
float d;
};

The equivalent C code would look something like this:
/******************************v-table structure *************************/
struct foo_vtable {
typeid * type_id_ptr;     // Type id structure pointer shows the type_id for a class
int offset;		  //
void (* ptr_to_a)(int);
void (* ptr_to_b)(float);
};

void foo_a(int) { }
void foo_b(float) { }

static type_id foo_type_id = { ... };  
static foo_vtable sfoo_vtable = { &foo_type_id, 0, foo_a, foo_b }; //Per class has only 1 vtable and its intialised wd v fun ptrs n type id n offset

struct foo {
foo_vtable * vtable; // gets initiated to &sfoo_vtable
int c;
float d;
};

Class type is stored separately - first ptr in the v-table. Motivation for this will be clear later.
Vtable has an offset 



***********************************************************************************************************************************
Virtual Table for Multiple inheritance and offsets;
****************************************************


class A
{
	int a;
	virtual funa(){}

};


class B
{
	int b;
	virtual funb(){}

};



class C: public A , public B
{
	int c;
	funb(){}  //Overides B function

};

C *pc = new C;

Inheritance V table Offset :
-----------------------------------
Offset 
+0: pointer to virtual method table of C (for A) wd the ame implentation of the function 
+4: value of int a
+8: pointer to virtual method table of C (for B) wd the function overidden C::funb
+12: value of int b
+16: value of int c

Virtual function behaviour With defaults at Base class functions
------------------------------------------------------------------
The virtual functions default argument will be called from the Base class if the pointer used is base class,
else with argument present and 
n struct A {
  virtual void f(int a = 7);
};
struct B : public A {
  void f(int a);
};
void m()
{
  B* pb = new B;
  A* pa = pb;
  pa->f(); //OK, calls pa->B::f(7)
  pb->f(); //error: wrong number of arguments for B::f()
}

Can a pure virtual function have an implementation?
-------------------------------------------------------------------------------------------

The quick answer to that question is yes! A pure virtual function can have an implementation in C++ – which is
something that even many veteran C++ developers do not know. So, using the SomeClass class from our example above,
we can have the following code:

class SomeClass {
public:
   virtual void pure_virtual() = 0;  // a pure virtual function
   // note that there is no function body	 
};

/*This is an implementation of the pure_virtual function
    which is declared as a pure virtual function.
    This is perfectly legal:
*/
void SomeClass::pure_virtual() {
    cout<<"This is a test"<<endl;
}
Why would you want a pure virtual function to have an implementation?

It is actually pretty rare to see a pure virtual function with an implementation in real-world code, but having
that implementation may be desirable when you think that classes which derive from the base class may need some 
sort of default behavior for the pure virtual function. So, for example, if we have a class that derives from our
SomeClass class above, we can write some code like this – where the derived class actually makes a call to the
pure virtual function implementation that is inherited:

//this class derives from SomeClass
class DerivedClass: public SomeClass {

virtual void pure_virtual() {

/*
Makes a call to the pure virtual function 
implementation that is inside the SomeClass
class. This can happen because DerivedClass
may not have anything appropriate to define
for this function, so it just calls the SomeClass's
implementation
*/

SomeClass::pure_virtual();  

}

};
Something else that is definitely worth noting in the code above is the fact that the call to the 
“SomeClass::pure_virtual();” function is valid because of the fact that the pure_virtual function declaration 
is public in the SomeClass class. That call would also be valid if the pure_virtual function declaration is protected,
because the DerivedClass does derive from the SomeClass class. However, if the pure_virtual function declaration was
private in the SomeClass class, then a compiler error would result when the “SomeClass::pure_virtual();” call is made
in the DerivedClass class, because it would obviously not have access to that function implementation.

Pure virtual functions can not have a definition inside the function declaration

If you do mistakenly try to give a declaration of a pure virtual function a definition as well, then the compiler will
return an error when it comes across that code. Note that there is however an exception to this in Microsoft’s Visual C++
implementation, which specifically allows this. This is also known as an inline definition, which is completely different 
from the use of the inline keyword – which you can read about here Inline vs macro. 
So, suppose we have the following code:

class SomeClass {
public:
  /*note that we added braces that are normally
     associated with a function body and definition:
  */
   virtual void pure_virtual() = 0 { }; //ERROR (except in MS VC++)
};
The code above is considered ill formed by the C++ 03 standard in Clause 10.4, paragraph 2, which says that “a function
declaration cannot provide both a pure-specifier and a definition”.

Running the code above will actually result in a compiler error, because a pure virtual function can not have a definition
within the declaration of the pure virtual function.




Virtual template example
-------------------------------------------------------------------
Is no reason you can't include a virtual function (pure or otherwise) in the template class definition, 
because that, in and of itself, does not generate any code, including the virtual table.

When we actually instantiate the template class, e.g. Base<int>, then the compiler only needs to build 
the virtual table for that one selected type, so it's not any different than a (pure or otherwise) virtual function
for a non-templated class.

template<typename T>
class Base {
public:
    virtual void Do(T x) const = 0;
};

template<typename T>
class Base : public Base<T> {
public:

    void Do(T x) const {
        // ...i
	cout<<x;
    }
};

Base<int> *ptr = new Base<int>;
ptr->Do(4);
Base<float> *Nptr = new Base<float>;
Nptr->Do(.334);
 
-------------------------------------------------------------
Virtual Constructors and Destructors
******************************************
A constructor cannot be virtual because at the time when the constructor is invoked the virtual table would not be
 available in the memory.
 Hence we cannot have a virtual constructor.


A virtual destructor is one that is declared as virtual in the base class and is used to ensure that destructors
are called in the proper order. It is to be remembered that destructors are called in the reverse order of 
inheritance. 
If a base  class pointer points to a derived class object and we some time later use the delete operator to delete the object, 
then the derived class destructor is not called. Refer to the code that follows:
#include <iostream.h>
class base
{
   public:
   ~base()
  {

  }
};

class derived : public base
{
   public:
   ~derived()
   {
 
   }
};

void main()
{

   base *ptr = new derived();
   // some code
   delete ptr;
}
 

In this case the type of the pointer would be considered. Hence as the pointer is of type base, the base 
class destructor would be called but the derived class destructor would not be called at all. 
The result is memory leak. In order to avoid this, we have to make the destructor virtual in the base class. 
This is shown in the example below:


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Inheriting from Multiple Classes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class Baz : public Foo, public Bar
    {
          // Etc.
    };
By listing multiple parents, the Baz object will have the following characteristics:
         A Baz object will support the public methods and contain the data members of both Foo
         and Bar.
         The methods of the Baz class will have access to protected data and methods in both Foo
         and Bar.
         A Baz object can be upcast to either a Foo or a Bar. Creating a new Baz object will automatically call the Foo and Bar default constructors, i


///////////////////////////////////////////////////////////
Naming Collisions and Ambiguous Base Classes 
///////////////////////////////////////////////////////////
Name Ambiguity
*******************
1)
class Dog
{
         virtual void eat() { cout <<  The dog has eaten  << endl; }
};
class Bird
{

        virtual void eat() { cout <<  The bird has eaten  << endl; }
};
class DogBird : public Dog, public Bird
{
};
int main()
{
    DogBird myConfusedAnimal;
    myConfusedAnimal.eat();   // BUG! Ambiguous call to method eat()
}


SOLUTION:
------------

The solution to the ambiguity is to either explicitly upcast the object, essentially hiding the undesired
version of the method from the compiler, or to use a disambiguation syntax. For example, the following
code shows two ways to invoke the Dog version of eat().
    static_cast<Dog>(myConfusedAnimal).eat();            // Slices, calling Dog::eat()
    myConfusedAnimal.Dog::eat();                         // Calls Dog::eat()

2) inherit from the same class twice:
++++++++++++++++++++++++++++++++++++++++++++++++++
class Dog {};
class Bird : public Dog {};
class DogBird : public Bird, public Dog {}; // BUG! Dog is an ambiguous base
class.


3) Diamond Inheritence:
+++++++++++++++++++++++++++++++++++++++++++++++++++
    The following code adds a sleep() method to the Animal base class and modifies the Dog and Bird
classes to inherit from Animal as a virtual base class. Without the virtual keyword, a call to sleep()
on a DogBird object would be ambiguous because both Dog and Bird would have inherited versions of
sleep() from Animal. However, when Animal is inherited virtually, only one copy of each method or
member exists in its descendents.

    public:
        virtual void eat() = 0;
        virtual void sleep() { cout <<  zzzzz...  << endl; }
};

class Dog : public virtual Animal
{
   virtual void eat() { cout <<  The dog has eaten  << endl; }
};

class Bird : public virtual Animal
{
   virtual void eat() { cout <<  The bird has eaten  << endl; }
};

class DogBird : public Dog, public Bird
{
    public:
        void eat() { Dog::eat(); }   //Implentaion of the upper virtual
};

int main(int argc, char** argv)
{
    DogBird myConfusedAnimal;
    myConfusedAnimal.sleep();   // Not ambiguous because Animal is virtual
}

About the memory layout
*************************
As a side note, the problem with the Dreaded Diamond is that the base class is present multiple times. So with regular inheritance, you believe you have:

  A
 / \
B   C
 \ /
  D
But in the memory layout, you have:

A   A
|   |
B   C
 \ /
  D
This explain why when call A::foo(), you have an ambiguity problem. But the real problem comes when you want to use a member
 variable of A. For example, let's say we have:

class A
{
    public :
       foo() ;
       int m_iValue ;
} ;
When you'll try to access m_iValue from D, the compiler will protest, because in the hierarchy, it'll see two m_iValue, 
not one. And if you modify one, say, B::m_iValue (that is the A::m_iValue parent of B), C::m_iValue won't be modified 
(that is the A::m_iValue parent of C).

This is where virtual inheritance comes handy, as with it, you'll get back to a true diamond layout, with not only 
one foo() method only, but also one and only one m_iValue.


////////////////////////////////////////////////////////////////////
Changing the Method Return Type
///////////////////////////////////////////////////////////////////
/  In C++, an overriding method can change the return type as
long as the original return type is a pointer or reference to a class, and the new return type is a pointer or
reference to a descendent class. Such types are called COVARIANT returns types. 

  This feature sometimes comes in handy when the superclass and subclass work with objects in a parallel hierarchy. That is,
another group of classes that is tangential, but related, to the first class hierarchy.

Ex: factory pattern

In place of superclass if void* is given results in return types are not used in method disambiguation.

////////////////////////////////////////////////////////////////////
If the Superclass Method Is Static

////////////////////////////////////////////////////////////////////
First of all, a method cannot be both static and virtual. This is the first clue that attempting to override
a static method will not do what you intend for it to do. If you have a static method in your subclass
with the same name as a static method in your superclass, you actually have two separate methods.


class SuperStatic
{
    public:
        static void beStatic() { cout <<  SuperStatic being static, yo  << endl;
};
class SubStatic :public  SuperStatic
{
    public:
        static void beStatic() { cout <<  SubStatic keepin  it static  << endl;
};
when virtual like implentation is done 
SubStatic mySubStatic;
SuperStatic& ref = mySubStatic;
mySubStatic.beStatic();
ref.beStatic(); 
 // The SuperStatic method is called C++ doesn t care what the object actually is when calling a static method. It only
cares about the compile-time type. 



static methods are bound to the class in which they are defined, not to any object.
A method in a class that calls a static method calls the version defined in that class,
independent of the run-time type of the object on which the original method is called.


________________________________________________________________________________________________
/////////////////////////////////////////////////////////////////////
CHAP 12: Understanding C++ Quirks and Oddities
////////////////////////////////////////////////////////////////////

1)  References :
 A reference in C++ is an alias just another name for the original variable. All modifications to the reference change the
value of the variable to which it refers. 
	a) Reference variables must be initialized as soon as they are created:
	***********************************************************************************
	int x = 3;
	int& xRef = x;

	b) You cannot create a reference to an unnamed value such as an integer literal, unless the reference is to a const value:
	***************************************************************************************************************************

	int& unnamedRef = 5; // DOES NOT COMPILE
	const int& unnamedRef = 5; // Works as expected
	
	c) Modyfying Reference :
	**********************************************************************************
	 int x = 3, y = 4;
	 int& xRef = x;
	 xRef = y; // Changes value of x to 4. Doesn t make xRef refer to y.

	 also 
		int& xRef = x;
		int& zRef = z;
		zRef = xRef; // Assigns values, not references
	
	d) Use of refrence , value change will change of :
	****************************************************************************************
		void swap(int& first, int& second)
		{
    			int temp = first;
    			first = second;
    			second = temp;
		}


	e) Pass-by-Reference versus Pass-by-Value:
	****************************************************************************************
	Pass-by-reference is required when you want to modify the parameter and see those changes reflected in the variable argument to the 
	function or method

         Pass-by-reference avoids copying the argument to the function, providing two additional benefits in some cases

	******************************************************************************************
	Use references instead of pointers unless you need to dynamically allocate memory
	or otherwise change, or free, the value to which the pointer points.

	
2) CONSTANTS :
			int z;
			const int& zRef = z;
			zRef = 4; // DOES NOT COMPILE
			
-----------------------------------------------------------------------------------			
3) ASSERT:

Compilers offer an assert() macro. The assert() macro returns TRUE if its parameter evaluates TRUE and takes some 
kind of action if it evaluates FALSE. Many compilers will abort the program on an assert() that fails; 

void analyze(char *string, int length)
{
   assert(string != NULL);     /* cannot be NULL */
   assert(*string != '\0');    /* cannot be empty */
   assert(length > 0);         /* must be positive */
}

 --------------------------------------------------------------------------------
Constant class variables:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1) The constant class variables instialisation inside the classes  
Class A
{
Const Int I ;   // This variable shuold be intilaised in the same line of declaration
A(int x){
{I = x;} //Will thorugh an error because assianing a constant value Cas a deep copying of the value will happen wer
}
A(int x):i(x)// C++ compiler will allow cas a shallow copying to the same memory is happening at intialisation
{}
}
2) A constant object declaration:
Whenevr a object is constant a
Const A a; // Any call to the Get or set Functions
a.i = 5 // Viollates the constaness of the object
Any set function changing the value will result in ERROR
3) Constant Overloading of the function :
	A
 	{
		int  Fun(int x ){x = 6}   // Normal function
		const int  Fun const (int x){} // Overloaded const function;
	};
	
	A a;   
	a.Fun(); // Calls the non constant function
	Const A b ; 
	b. Fun(); // Calls the  constant function

-----------------------------------------------------------------------------------------------
Constant pointer and constant pointing to
----------------------------------------------------------------------------------------------
a) const int * ptr = &i;
// Pointer is pointing towards a const variable so the value will be constant .
	*Ptr = 56; (ERROR : not  allowed as compiler will consider it as a constant integer but the pointer is non const )
	Ptr = &j ; // A non-const pointer can be redirected to point to other addresses
b) int * const ptr = &i;
a const pointer must be initialized to a value upon declaration, and its value can not be changed. The pointing value is not conatant
	*ptr = 56(A pointer to a non-const value can change the value it is pointing to)
	Ptr = &j ; (Error: Not allowed A const pointer always points to the same address, and this address can not be changed.)
c) const int* const   ptr (this will not allow any of the above)
 
----------------------------------------------------------------------------------------------
The keyword ‘explicit

----------------------------------------------------------------------------------------------
• DataBase(Person const &): the DataBase initially contains a single Person object;
• DataBase(istream &in): the data about multiple persons are read from in.
• DataBase(size_t count, istream &in = cin): the data ofcountpersons are read from
in, by default the standard input stream.
The above constructors all are perfectly reasonable. But they also allow the compiler to compile the
following code without producing any warning at all:
DataBase db;
DataBase db2;
Person person;
db2 = db; // 1
db2 = person; // 2
db2 = 10; // 3
db2 = cin; // 4
Statement 1 is perfectly reasonable: db is used to rede?ne db2. Statement 2 might be understandable since we designed DataBase to contain Person objects. Nevertheless, we might question the
logic that’s used here as a Person is not some kind of DataBase. The logic becomes even more
opaque when looking at statements 3 and 4. Statement 3 in effect waits for the data of 10 persons
to appear at the standard input stream. Nothing like that is suggested by db2 = 10.
All four statements are the result of implicit promotions. Since constructors accepting, respectively a
Person, an istream, and a size_t and an istream have been de?ned for DataBase and since the
assignment operator expects a DataBase right-hand side (rhs) argument the compiler ?rst converts
the rhs arguments to anonymous DataBase objects which are then assigned to db2.
It is good practice to prevent implicit promotions by using the explicit modi?er when declaring
a constructor. Constructors using the explicit modi?er can only be used to construct objects
explicitly. Statements 2-4 would not have compiled if the constructors expecting one argument would
have been declared using explicit. E.g.,
explicit DataBase(Person const &person);
explicit DataBase(size_t count, std:istream &in);
Having declared all constructors accepting one argument asexplicitthe above assignments would
have required the explicit speci?cation of the appropriate constructors, thus clarifying the programmer’s intent:

3) STATIC:
	static means only internal linkage . A function or variable declared as static cannot be accessd by the other files at thetime of linking . 

	static Variables in Functions
   The final use of the static keyword in C++ is to create local variables that retain their values between
   exits and entrances to their scope.

Static Method:
-------------------------------------------
sometimes apply to the class as a whole, not to each object. You can write static methods as well as members. As an example, consider the SpreadsheetCell class .It has two helper methods: stringToDouble() and doubleToString(). These methods don t access information about specific objects, so they could be static.
	                                                                             However, note that static
methods are not called on a specific object, so they have no this pointer, and are not executing for a spe-
cific object with access to its non-static members. In fact, a static method is just like a regular func-
tion. The only difference is that it can access private and protected static data members of the class
and private and protected non-static data members on other objects of the same type.
        You cannot access non-static data members inside a static method.

		

4) EXTERNAL :
      Source file, including functions and global
variables, has a linkage that is either internal or external. External linkage means that the name is avail-
able from other source files. By default global variables have external linkage.

*******	keyword : extern 
When you specify a name as extern, the compiler treats it as a declaration, not a definition.You must provide a separate definition line for the variable without the extern keyword. 
extern int x;
int x = 3;
For example, consts and typedefs have internal linkage by default. You can use extern to give them external linkage.

In C++ extern are declared in header files and alll the Files using those variables include this header file.

test.h
extern int k;

test.C
#include<test.h>
int k =6





5) CASTING:
Assigning two different types or kind of variable:

1) const_cast:                                                  
You can use it to cast away const-ness of a variable. It is the only cast of the four that is allowed to cast away const-ness.     you some-
times find yourself in a situation where a function is specified to take a const variable, which it must
then pass to a function that takes a non-const variable.



	void f(const char* str)
	{
	    // Function body omitted for brevity
	    g(const_cast<char*>(str));
	    // Function body omitted for brevity
	}



2) static cast:
            use static_cast to perform explicitly conversions that are allowed because of user-
defined constructors or conversion routines.
	int i = 3;
	double result = static_cast<double>(i) / 10;
---------------------------------------------------------------------------------
Base* b;
Derived* d = new Derived();
b = d; // Dont need a cast to go up the inheritance hierarchy
d = static_cast<Derived*>(b); // Need a cast to go down the hierarchy
Base base;
Derived derived;
Base& br = base;
Derived& dr = static_cast<Derived&>(br);

3)reinterpret_cast
======================
      einterpret_cast is a bit more powerful, and concomitantly less safe, than the static_cast.
You can use it to perform some casts that are not technically allowed by C++ type rules, but which might
make sense to the programmer in some circumstances. For example, you can cast a pointer type to any
other pointer type, even if they are unrelated by an inheritance hierarchy. Similarly, you can cast a refer-
ence to one type to a reference to another type, even if the types are unrelated


class X {};
class Y {};
int main(int argc, char** argv)
{
    int i = 3;
    X x;
    Y y;
    X* xp;
    Y* yp;
    // Need reinterpret cast to perform pointer conversion from unrelated classes
    // static_cast doesn t work.
    xp = reinterpret_cast<X*>(yp);
    // Need reinterpret_cast to go from pointer to int and from int to pointer
    i = reinterpret_cast<int>(xp);
    xp = reinterpret_cast<X*>(i);
    // Need reinterpret cast to perform reference conversion from unrelated classes
    // static_cast doesn t work.
    X& xr = x;
    Y& yr = reinterpret_cast<Y&>(x);
    return (0);
}


One practical use of reinterpret_cast is in a hash function, which maps a value to an index in such a way that two distinct values rarely end up with the same index.

// expre_reinterpret_cast_Operator.cpp
// compile with: /EHsc
#include <iostream>

// Returns a hash code based on an address
unsigned short Hash( void *p ) {
   unsigned int val = reinterpret_cast<unsigned int>( p );
   return ( unsigned short )( val ^ (val >> 16));
}

using namespace std;
int main() {
   int a[20];
   for ( int i = 0; i < 20; i++ )
      cout << Hash( a + i ) << endl;
}






4) dynamic_cast
                                                     the dynamic_cast provides a run-time check on casts
within an inheritance hierarchy. You can use it to cast pointers or references. dynamic_cast checks the
runtime type information of the underlying object at run time. If the cast doesn t make sense,
dynamic_cast returns NULL (for the pointer version) or throws a bad_cast exception (for the reference
version).

The dynamic cast is used when their 

class Base
{
virtual f(){}

}

class derived : public base
{
}
B b;
D r
Base &br = b;
Base &br1 = d;

try {
      Derived& dr1 = dynamic_cast<Derived&>(br);
	
	// it will catch a bad cast only dr1 = br1 is allowed 
	// Even non polymorphic(No virtuals in inheritance) clases will also though errors
	
} catch (bad_cast&) {
    cout <<  Bad cast!\n ;
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'''



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

RTTI
RTTI is short for Run-time Type Identification. RTTI is to provide a standard way for a program to determine the type of object during runtime.
In other words, RTTI allows programs that use pointers or references to base classes to retrieve the actual derived types of the objects to which 
these pointers or references refer.

RTTI is provided through two operators:
The typeid operator, which returns the actual type of the object referred to by a pointer (or a reference).
The dynamic_cast operator, which safely converts from a pointer (or reference) to a base type to a pointer (or reference) to a derived type.


	Employee lee;
	Programmer park;

	Employee *pEmpA = &lee;
	Employee *pEmpB = &park;

	// check if two object is the same
	if(typeid(Programmer) == typeid(lee)) {
		Programmer *pProg = (Programmer *)&lee; 
		pProg->coding();
	}
	if(typeid(Programmer) == typeid(park)) {
		Programmer *pProg = (Programmer *)&park; 
		pProg->coding();
	}

	pEmpA->show_id();
	pEmpB->show_id();



//UPCAST AND DOWNCAST 
**********************************
Employee employee;
	Programmer programmer;

	// upcast - implicit upcast allowed
	Employee *pEmp = &programmer;

	// downcast - explicit type cast required
	Programmer *pProg = (Programmer *)&employee;


	// Upcasting: safe - progrommer is an Employee 
	// and has his id to do show_id().
	pEmp->show_id();
	pProg->show_id();

	// Downcasting: unsafe - Employee does not have
	// the method, coding().
       // compile error: 'coding' : is not a member of 'Employee'
	// pEmp->coding(); 
	pProg->coding();






++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
5) Deleting an array :

dsyu876

Mutable Data Members
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Sometimes you write a method that is  logically  const but happens to change a data member of the
 object. This modification has no effect on any user-visible data, but is technically a change, so the com-
 piler won t let you declare the method const. For example, suppose that you want to profile your

	                        The solution is to make your new counter variable mutable, which tells the com-
piler that it s okay to change it in a const method. 


mutable int mNumAccesses;
double SpreadsheetCell::getValue() const
{
    mNumAccesses++;
    return (mValue);
}

Friends
++++++++++++++++++++++++++++
Class are that other classes or nonmember functions are friends, and can access
protected and private data members and methods. 
 

 Class SpreadsheetCell
{
     public:
         friend class Spreadsheet;
         // Remainder of the class omitted for brevity
	friend bool checkSpreadsheetCell(const SpreadsheetCell &cell);
};

lazy initialization;
**********************
lazy initialization is the tactic of delaying the creation of an object, 
the calculation of a value, or some other expensive process
 until the first time it is needed.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CHAPTER 13 MEMORY MANAGMENT:
_++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Multidimensional stack Arrays
**************************************	
size of a multidimensional array is all of its dimensions multiplied together, then multiplied by the
size of a single element in the array. In Figure 13-8, the three-by-three board is 3*3*1 = 9 bytes, assuming
that a character is 1 byte. For a four-by-seven board of characters, the array would be 4*7*1 = 28 bytes.

        You allocate memory with the array version of new (new[]), you must release it with the array ver-
sion of delete (delete[]). This version will automatically destruct the objects in the array in addition to
releasing the memory associated with them. If you do not use the array version of delete, your program
may behave in odd ways. In some compilers, only the destructor for the 0th element of the array will be
called because the compiler only knows that you are deleting a pointer to an object.



Simple* mySimpleArray = new Simple[4];
// Use mySimpleArray.
delete[] mySimpleArray;
		


 Multidimensional Heap Arrays
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           

Reason for having dynamic memory:
===================================================
The dynamic memeory is allocated in the run time on the fly so that the most important implication comes when its 
dynamic array alocation with size only know at the run time .


						   At first, it might seem like the correct way to declare and allocate a
dynamically allocated multidimensional array is as follows:
     char** board = new char[i][j]; // BUG! Doesn t compile
This code doesn t compile because heap-based arrays don t work like stack-based arrays. Their memory
layout isn t contiguous, so allocating enough memory for a stack-based multidimensional array is incor-
rect. Instead, you must start by allocating a single contiguous array for the first subscript dimension of a
heap-based array.

Multidimensional Heap Array
***************************************
	char** board = new char[i][j]; // BUG! Doesn t compile

This code doesn t compile because heap-based arrays don t work like stack-based arrays. Their memory
layout isn t contiguous, so allocating enough memory for a stack-based multidimensional array is incor-
rect. Instead, you must start by allocating a single contiguous array for the first subscript dimension of a
heap-based array.

1)
char** allocateCharacterBoard(int xDimension, int yDimension)
{
    char** myArray = new char*[xDimension]; // Allocate first dimension
    for (int i = 0; i < xDimension; i++) {
        myArray[i] = new char[yDimension];  // Allocate ith subarray
    }
    return myArray;
}

2)
void releaseCharacterBoard(char** myArray, int xDimension)
{
    for (int i = 0; i < xDimension; i++) {
        delete[] myArray[i];    // Delete ith subarray
    }
    delete[] myArray;           // Delete first dimension
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  c advantages of exceptions over the ad hoc approaches in C and C++.
 Return codes from functions can be ignored. Exceptions cannot be ignored: if your program fails
    to catch an exception, it will terminate.
    Integer return codes do not contain any semantic information. Different numbers can mean dif-
    ferent things to different programmers. Exceptions can contain semantic information in both
    their type names and, if they are objects, in their data.
    Integer return codes are devoid of surrounding information. You can use exceptions to pass as
    much information as you want from the code that finds the error to the code that handles it.
    Exceptions can also be used to communicate information other than errors, though many pro-
    grammers consider that an abuse of the exception mechanism.
    Exception handling can skip levels of the call stack. That is, a function can handle an error that
    occurred several function calls down the stack, without error-handling code in the intermediate
    functions. Return codes require each level of the call stack to clean up explicitly after the previ-
    ous level.

USING Error 
#include <exception>
try {
    readIntegerFile(fileName, myInts);
} catch (const exception& e) {
    cerr <<  Unable to open file   << fileName << endl;
    exit (1);
}



USE of throw an exception:
-------------------------------------------------

void readIntegerFile(const string& fileName, vector<int>& dest)
{

	istr.open(fileName.c_str());
	if (istr.fail()) {
				  throw invalid_argument("");
			  }
			  {
				istr.close();
				throw runtime_error("");
			   }
}

try
{
    
	readIntegerFile(fileName, myInts);
}
 catch (const invalid_argument& e)
 {
    cerr << Unable to open file << fileName << endl;
    exit (1);
  } 
 catch (const runtime_error& e)
 {
    cerr <<Error reading file  << fileName << endl;
    exit (1);
 }

Throwing Multiple Exceptions:
----------------------------------------------------------------------
Multiple exceptions are caught by multiple catch

fun()
{

if (istr.fail()) {
    // We failed to open the file: throw an exception.
    throw invalid_argument();
}
else
	throw runtime_error();
}

While catching:
---------------
  catch (const invalid_argument& e) {
    cerr <<  Unable to open file   << fileName << endl;
    exit (1);
} catch (const runtime_error& e) {
    cerr <<  Error reading file   << fileName << endl;
    exit (1);

c++ also proviodes Throw list to  to specify the exceptions a function or method intends to throw, 
It it just a declaration after the function name

fun()throw (invalid_argument, runtime_error)
{   body of the function }

Throw lists donâ€ prevent functions from throwing unlisted exception types, but
they prevent the exception from leaving the function.

________________________________________________________________________
rethrow an exception when the catch cannot handle it:
void f() 
{
  try{
    cout << "In try block of f()" << endl;
    cout << "Throwing exception of type E1" << endl;
    E1 myException;
    throw myException;
    }
catch (E1& e) {
    cout << "In handler of f(), catch (E1& e)" << endl;
    cout << "Exception: " << e.message << endl;
    throw;  // this throw will b handled ny the main caller
  }

}


 try {
    cout << "In try block of main()" << endl;
    f();
  }

catch(...){

	//here the thow will be handled

}

.------------------------------------------------------------------------
s, if Incomplete’s constructor would actually have allocated some memory, the program would
suffer from a memory leak. To prevent this from happening, the following counter measures are
available:
• Prevent the exceptions from leaving the constructor.
If part of the constructor’s body may generate exceptions, then this part may be surrounded
by a try block, allowing the exception to be caught by the constructor itself. This approach is
defensible when the constructor is able to repair the cause of the exception and to complete its
construction as a valid object.
• If an exception is generated by a base class constructor or by a member initializing constructor
then a try block within the constructor’s body won’t be able to catch the thrown exception.
This always results in the exception leaving the constructor and the object is not considered to
have been properly constructed. A try block may include the member initializers, and the try
block’s compound statement becomes the constructor’s body as in the following example:
class Incomplete2
{
Composed d_composed;
public:
Incomplete2()
try
:
d_composed(/* arguments */)
{
// body
}
catch (...)
{}
};
---------------------------------------------------------------------------
Stack unwinding (C++ only)
When an exception is thrown and control passes from a try block to a handler, the C++ run time calls destructors
 for all automatic objects constructed since the beginning of the try block. This process is called stack unwinding. 
The automatic objects are destroyed in reverse order of their construction. (Automatic objects are local objects that
 have been declared auto or register, or not declared static or extern.

If an exception is thrown during construction of an object consisting of subobjects or array elements, destructors are 
only called for those subobjects or array elements successfully constructed before the exception was thrown. 
A destructor for a local static object will only be called if the object was successfully constructed.


struct E {
  const char* message;
  E(const char* arg) : message(arg) { }
};

void my_terminate() {
  cout << "Call to my_terminate" << endl;
};

struct A {
  A() { cout << "In constructor of A" << endl; }
  ~A() {
    cout << "In destructor of A" << endl;
    throw E("Exception thrown in ~A()");
  }
};

struct B {
  B() { cout << "In constructor of B" << endl; }
  ~B() { cout << "In destructor of B" << endl; }
};

int main() {
  set_terminate(my_terminate);

  try {
    cout << "In try block" << endl;
    A a;
    B b;
    throw("Exception thrown in try block of main()");
  }
  catch (const char* e) {
    cout << "Exception: " << e << endl;
  }
  catch (...) {
    cout << "Some exception caught in main()" << endl;
  }

  cout << "Resume execution of main()" << endl;
}


o/p:
In try block
In constructor of A
In constructor of B
In destructor of B
In destructor of A // a sends exception in destructor which calls my terminate
Call to my_terminate





For not thowing unexpected exception
------------------------------------------------------------------------
When a function throws an exception that is not listed in its throw list, C++ calls a special function
unexpected(). The built-in implementation of unexpected() simply calls terminate(). However,
just as you can set your own terminate_handler, you can set your own unexpected_handler.
Unlike in the terminate_handler, you can actually do something other than just terminate the pro-
gram in the unexpected_handler. Your version of the function must either throw a new exception or
terminate the program â€” it can t just exit the function normally. If it throws a new exception, that excep-
tion will be substituted for the unexpected exception as if the new one had been throw originally. If this
substituted exception is also not listed in the throw list, the program will do one of two things. If the
throw list for the function specifies bad_exception, then bad_exception will be thrown. Otherwise,
the program will terminate. 
To handle an unexpected exception write a handler function 


-----------------------------------------------------------------------

        a function throws an exception that is not listed in its throw list, C++ calls a special function
unexpected(). The built-in implementation of unexpected() simply calls terminate(). However,
just as you can set your own terminate_handler, you can set your own unexpected_handler.
Unlike in the terminate_handler,
  void f(int i) throw(Up, Fit) {
switch(i) {
case 1: throw Up();
case 2: throw Fit();
}
g();
}
 
// void g() {} // Version 1
void g() { throw 47; } // Version 2
 
void my_unexpected() {
cout << "unexpected exception thrown" << endl;
exit(0);
}
 
int main() {
set_unexpected(my_unexpected); // (Ignores return value)
for(int i = 1; i <=3; i++)
try {
f(i);
} catch(Up) {
cout << "Up caught" << endl;
} catch(Fit) {
cout << "Fit caught" << endl;
}
} /// 
The my_unexpected( ) function has no arguments or return value, following the proper form for a custom unexpected( ) function. 
It simply displays a message so that you can see that it was called, and then exits the program (exit(0) is used here so that the book s
 make process is not aborted). Your new unexpected( ) function should not have a return statement.
-----------------------------------------------------------------------
If the exception thrown from your unexpected handler is not allowed by the original function s specification, one of the following occurs:

1.  If std::bad_exception (defined in <exception>) was in the function s exception specification, 
the exception thrown from the unexpected handler is replaced with a std::bad_exception object, and the search resumes 
from the function as before.

2.  If the original function s specification did not include std::bad_exception, terminate( ) is called.

The following program illustrates this behavior:


void g() throw(A, bad_exception) { t(); }
void t() { throw B(); }

void my_uhandler1() { throw A(); }
void my_uhandler2() { throw; }

void my_thandler() {
cout << "terminate called" << endl;
exit(0);
}






----------------------------------------------------------------------
Special cases of exception:
------------------------------
1)  A function with no exception specification allows all exceptions. A function with an exception specification that has an empty type_id_list, throw(), 
does not allow any exceptions to be thrown.
	void translate()throw()
  	{}

	void translate()//it can thorw any exception 
  	{}

2)  an override of that function in a derived class must not add any other exception types to the specification list because that would break any
 programs that adhere to the base class interface. 

***You can, however, specify fewer exceptions or none at all, since that doesn t require the user to do anything differently. 


3) You can also specify anything that is-a A in place of A in the derived function s specification

class Base {
public:
class BaseException {};
class DerivedException : public BaseException {};

virtual void f() throw(DerivedException)
 {
					throw DerivedException();
 }

virtual void g() throw(BaseException)
 {
	throw BaseException();
 }
};
 
class Derived : public Base {
public:
void f() throw(BaseException)//f virtual function will ERROR as BaseException is a kind of derived 
{
	throw BaseException();
}
virtual void g() throw(DerivedException)
 {
throw DerivedException();  //g virtual function will allowed as DerivedException is a kind of base
}

Some EXCEPTION 
----------------------------------------------------------------------

exception	description

bad_alloc	thrown by new on allocation failure
bad_cast	thrown by dynamic_cast when fails with a referenced type
bad_exception	thrown when an exception type doesn't match any catch
bad_typeid	thrown by typeid
ios_base::failure	thrown by functions in the iostream library

catch (exception& e)
{
    cout << "Standard exception: " << e.what() << endl;
}
------------------------------------

Overloading C++ Operators
**********************************
class A
{ int i};

A a,b;

1) - operator  

const SpreadsheetCell operator-() const
{
    SpreadsheetCell newCell(*this);
    newCell.set(-mValue); // call set to update mValue and mStr
    return (newCell);
}

Use:  - b

-------------------------------------
2()++ operator  



SpreadsheetCell& SpreadsheetCell::operator++()
{
    set(mValue + 1);
    return (*this);

}

her return is reference
Use:  ++a
-------------------------------------

SpreadsheetCell SpreadsheetCell::operator--(int)
{
    SpreadsheetCell oldCell(*this); // Save the current value before incrementing
    set(mValue - 1); // Increment
    return (oldCell); // Return the old value.
}

a--
 here return is obj
-------------------------------------
ostream& operator<<(ostream& ostr, const SpreadsheetCell& cell)
{
    ostr << cell.mString;
    return (ostr);
}
istream& operator>>(istream& istr, SpreadsheetCell& cell)
{
    string temp;
    istr >> temp;
    cell.set(temp);
    return (istr);
}

cin >> a
cout << a

-------------------------------------
class Array
{
    public:
        Array();
        ~Array();
        int& operator[](int x);
        const int& operator[](int x); 
};


const int& Array::operator[](int x) const
{
    if (x < 0 || x >=mSize) {
        throw out_of_range(  );
    }
    return (mElems[x]);
}


for (i = 0; i < 10; i++) {
    arr[i] = 100; // Calls the non-const operator[] because
                  // arr is a non-const object.
void printArray(const Array& arr, int size)
{

for (int i = 0; i < size; i++) {
    cout << arr[i] <<    ; // Calls the const operator[] because arr is a const
    cout << endl;
}
                         // object.


-----------------------------------------------------
A Variable Argument List is not Function Overloading
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

Actually, this is not a case of function overloading – the printf function is just using a feature of C
known as variable argument lists. This should not be confused with function overloading. So, to answer
the question, Standard C does not support function overloading.

As an interesting side note, C++ doesn’t really have function overloading. What it does have is a means of
faking it: the C++ compiler actually ‘mangles’ (or changes) function names according to the function’s parameters.
So, functions that share the same name but have different numbers or types of parameters can be differentiated
when invoked. Also, since the ‘mangling’ of function names is not standardized, it’s usually difficult to link 
object files compiled by different C++ compilers.



//Implementation of overloaded function-call operator

-------------------------------------
Functors (Function Objects or Functionals) are simply put object + (). In other words, a functor is any object that can be used
 with () in the manner of a function.

struct absValue
{


   int a;

	absValue(int i):a(i){}
		
	float operator()(float f)
	 {
		return f > 0 ? f : -f;
	}
};

int main( ) 
{ 
	using namespace std;

	float f = -123.45;
	absValue aObj(56);
	float abs_f = aObj(f);



Some advantages of function object listed in "The C++ Standard Library" by Nicolai M. Josuttis.

-------------------------------------
Function object are "smart functions." 
Objects that behave like pointers are smart pointers. This is similarly true for objects that behave like functions:
 They can be "smart functions" because they may have abilities beyond operator (). Function objects may have other member functions and attributes. 
This means that function objects have a state. ....
Each function object has its own type. 

Ordinary functions have different types only when their signatures differ. However, function objects can have different types when their
 signatures are the same. In fact, each functional behavior defined by a function object has its own type. This is a significant improvement 
for generic programming using templates because you can pass functional behavior as a template parameter. ...
Function objects are usually faster than ordinary functions. 
The concept of templates usually allows better optimization because more details are defined at compile time. T
hus, passing function objects instead of ordinary functions often results in better performance.


Predicates
-------------------------------------
A special auxiliary function for algorithm is a predicate. Predicates are functions that return a Boolean value (or something that can be implicitly 
converted to bool). In other words, a predicate class is a functor class whose operator() function is a predicate, i.e., its operator() returns true or
 false.

Predicates are widely used in the STL. The comparison functions for the standard associative containers are predicates, and predicate functions are
 commonly passed as parameters to algorithms like find_if. Depending on their purpose, predicates are unary or binary
















--- OVERLOADING NEW AND DELETE OPERATORS---------------------------------

we must deal with those two tasks (allocation and construction). What we can change is how the memory for an object is allocated. 
The new operator calls a function It is operator new.

	void * operator new (size_t size); 
// return is void*. Since this function returns a pointer to raw which is uptyped and uninitialized memory 
large enough to hold an object of the specified type. 
The size_t specifies how much memory to allocate. It knows nothing about constructors. All operator new understands is memory allocation. That's it.
It is the job of the new operator to take the raw memory that the operator new returns and make it into an object. When a compiler sees the following line,

	string *ptrStr = new string("Where is my place in Memory?");
the compiler generate a code something like this:

1st step:	void *ptrRawMemory = operator new(sizeof(string));
					It obtains raw memory for a string object.

2nd Step:	call string::string("Where is my place in Memory?") 
		

3rd step:
	It then initialize the object in the memory by calling a constructor.

	string *ptrStr = static_cast(ptrRawMemory);
The line of code above makes ptrString point to the new object.

When we use a delete expression to delete a dynamically allocated object:

delete ptr;
two things happen. First, the appropriate destructor is run on the object to which ptr points. Then, the memory used by the object is 
freed by calling a operator delete function.Unlike other operator functions, such as operator=, the operator new and operator delete functions 
do not overload the new or delete.





Two overloaded versions of operator new and operator delete functions:

void *operator new(size_t);	// allocate an object
void *perator new[](size_t);  	// allocate an array

void *operator delete(void*);	// free an object
void *perator delete[](void*); 	// free an array

OPerator new [] ypes :
***************************************************************
The various versions of the operator new []
void* operator new[] (std::size_t size) throw (std::bad_alloc);
void* operator new[] (std::size_t size, const std::nothrow_t& nothrow_constant) throw();
void* operator new[] (std::size_t size, void* ptr) throw();


Parameters'
***************************************************************
size
Size in bytes of the requested memory block.
size_t is an integral type.
nothrow_constant
The constant nothrow.
This parameter is only used to distinguish it from the first version.
 When the nothrow constant is passed as second parameter to operator new, 
operator new returns a null-pointer on failure instead of throwing a bad_alloc exception.
nothrow_t is the type of constant nothrow.
ptr
A pointer to a memory block where the object is to be constructed


calls:
***************************************************************
// uses first version:
  int * p1 = new int[5];

  // uses second version:
  int * p2 = new (nothrow) int[4];

  // uses third version:
  pair <myclass*,ptrdiff_t> p3 = get_temporary_buffer<myclass>(3);
  new (p3.first) myclass[3];   // calls constructors
  return_temporary_buffer(p3.first);

----------------------------------------------------------------------
 Memory Fragmentation:
  "large" (32 bytes) expanse of free memory:
----------------------------------
|                                |
----------------------------------
Now, allocate some of it (5 allocations):

----------------------------------
|aaaabbccccccddeeee              |
----------------------------------
Now, free the first four allocations but not the fifth:
----------------------------------
|              eeee              |
----------------------------------
Now, try to allocate 16 bytes. Oops, I can't, even though there's nearly double that much free.

On systems with virtual memory, fragmentation is less of a problem than you might think,
 because large allocations only need to be contiguous in virtual address space, not in physical address space.
 So in my example, if I had virtual memory with a page size of 2 bytes then I could make my 16 byte allocation 
 with no problem. Physical memory would look like this:

----------------------------------
|ffffffffffffffeeeeff            |
----------------------------------
whereas virtual memory (being much bigger) could look like this:

------------------------------------------------------...
|              eeeeffffffffffffffff                   
------------------------------------------------------...
The classic symptom of memory fragmentation is that you try to allocate a large block and you can't, even though you
 appear to have enough memory free. Another possible consequence is the inability of the process to release memory back 
 to the OS (because there's some object still in use in all the blocks it has allocated from the OS, even though those 
 blocks are now mostly unused).

Tactics to prevent memory fragmentation in C++ work by allocating objects from different areas according to their size 
and/or their expected lifetime. So if you're going to create a lot of objects and destroy them all together later, allocate
 them from a memory pool. Any other allocations you do in between them won't be from the pool, hence won't be located in 
 between them in memory, so memory will not be fragmented as a result.

Generally you don't need to worry about it much, unless your program is long-running and does a lot of allocation and freeing.
 It's when you have mixtures of short-lived and long-lived objects that you're most at risk, but even then malloc will do its
 best to help. Basically, ignore it until your program has allocation failures or unexpectedly causes the system to run low on 
 memory (catch this in testing, for preference!).

The standard libraries are no worse than anything else that allocates memory, and standard containers all have an Alloc 
template parameter which you could use to fine-tune their allocation strategy if absolutely necessary.

Q.How can I tell if memory fragmentation is a problem for my application? What kind of program is most likely to suffer?
A: 
memory fragmentation is a problem if your program uses much more system memory than its actual paylod data would require 
(and you've ruled out memory leaks).

Q.What are good common ways to deal with memory fragmentation?

A: 
Use a good algorithm for allocating memory. Instead of allocating memory for a lot of small objects, pre-allocate memory 
for a contiguous array of those smaller objects. Sometimes being a little wasteful when allocating memory can go along way 
for performance and may save you the trouble of having to deal with memory fragmentation.




-------------------------------------

template <typename T>
class Pointer
{
    public:
        Pointer(T* inPtr);
        ~Pointer();
        T& operator*();
        const T& operator*() const;
    protected:
        T* mPtr;
    private:
        Pointer(const Pointer<T>& src);
        Pointer<T>& operator=(const Pointer<T>& rhs);
};
template <typename T>
T& Pointer<T>::operator*()
{
    return (*mPtr);
}




-------------------------------------


Conversion Operators
SpreadsheetCell::operator string() const
{
    return (mString);
}
 





-------------------------------------
2)  here is the smart pointer template class definition, without the dereference operators filled in yet:
    template <typename T>
    class Pointer
    {
          public:
                Pointer(T* inPtr)
    		{
          		mPtr = inPtr;
    		}

                ~Pointer()
    		{
          		delete mPtr;
    		}
		T* operator->()
		{
   		 	return (mPtr);
		}
		
		T& operator*()
		{
   			 return (*mPtr);
		}


               // Dereference operators will go here.
	
          protected:
               T* mPtr;
          private:
               // Prevent assignment and pass by reference.
               Pointer(const Pointer<T>& src);
               Pointer<T>& operator=(const Pointer<T>& rhs);
    };
This smart pointer is about as simple as you can get. All it does is store a dumb pointer and delete it
when the object is destroyed. The implementations are equally simple: the constructor takes a real
( dumb ) pointer, which is stored as the only data member in the class. The destructor frees the pointer.

You would like to be able to use the smart pointer template like this:
   
    int main(int argc, char** argv)
    {
          Pointer<int> smartInt(new int);
          *smartInt = 5; // Dereference the smart pointer.
          cout << *smartInt << endl;
  	  Pointer<SpreadsheetCell> smartCell(new SpreadsheetCell);
  	  smartCell->set(5); // Dereference and member select the set method.
  	  cout << smartCell->getValue() << endl;
  	  return (0);
	
   }


---------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------

 
 Vector insertions 
----------------------------------------------

Vector put memory in baches if it reaches a batch ed then it will reallocate the whol memory in a new batch and add the new elemnt and 
delete the older batch.Vectors are really first for add/del last element as like stacks. the other operations r not as good.
The way the Sequential Containers(Vectors,map) ALLOCATION OF MEMORY is
 
Allocators:
****************
Most containers use a special object for allocating the memory that is managed by them. This object
is called an allocator, and it’s type is (usually by default) speci?ed when a container is constructed. A
container’s allocator can be obtained using the container’s get_allocator member, which returns
a copy of the allocator used by the container.
 
1) value_type *address(value_type &object)    [returns the address of object]
 
2) value_type *allocate(size_t count)  [allocates raw memory for holding count values of the container’s value_type ]
 
3) void destroy(value_type *object)   [calls object’s destructor (but doesn’t deallocate object’s own memory) ]
 
4) void deallocate(value_type *object, size_t count)
 
[calls operator delete to delete object’s memory, previously allocated by allocate.]
 
5) size_t max_size()
[returns the maximum number of elements that allocate can allocate]
 
 
 
Code :
******************
 
int main()
{
 
vector<string> vs;
//lETS Invoke the allocator object
 
allocator<string> alloc = vs.get_allocator(); // get the allocator
// alloc. space for 3 strings
 
string *sp = alloc.allocate(3); // its like vector<>(3)
// initialize 1st string
 
alloc.construct(&sp[0], "hello world"); // vector.insert()
alloc.construct(&sp[1], sp[0]); // use the copy constructor v1 = v2
 
//alloc.construct(&sp[2], 12, '='); // string of 12 = chars
cout << sp[0] <<'\n' << sp[1] << '\n' << '\n' << "2 strings could have allocated " << alloc.max_size() << " strings\n";
for (size_t idx = 0; idx != 2; ++idx)
        alloc.destroy(sp + idx); // delete the string
 
// contents
alloc.deallocate(sp, 2); // and delete sp itself again.
}
 
 
The STL contains sequence containers and associative containers. The standard sequence containers include vector,
 deque, and list. The standard associative containers are set, multiset, map, and multimap. There are also container adaptors
 queue, priority_queue, and stack, that are containers with specific interface, using other containers as implementation.


Creating vectors:
******************
 // constructors used in the same order as described above:
  std::vector<int> first;                                // empty vector of ints
  std::vector<int> second (4,100);                       // four ints with value 100
  std::vector<int> third (second.begin(),second.end());  // iterating through second
  std::vector<int> fourth (third);                       // a copy of third

  // the iterator constructor can also be used to construct from arrays:
  int myints[] = {16,2,77,29};
  std::vector<int> fifth (myints, myints + sizeof(myints) / sizeof(int) );





Modifiers:
******************


1) for(int i= 0 ; i<=6;i++)
                d.push_back(i);
                d.pop_back(); //Delete last element, effectively reducing the container size by one. No return 


2) d.insert(d.end(),1,0);  // one element wd value 0 at postion end(0

3) d.insert(d.begin() + d.size()/2, 1, 1);// At postion middle

4) d.erase(d.begin() +3);// erase at index 3

d.erase(d.begin() +3,d.begin() +5 );// erase at index 3 to 5 all 3 elemnts

5) Assign 
Assigns new contents to the vector, replacing its current contents, and modifying its size accordingly.
d.assign (7,100) // 7 ints with a value of 100
iterator version of assign 
std::vector<int>::iterator it;
it=b.begin()+1;

 d1.assign (it,first.end()-1); // the 5 central values of d


6) Exchanges the value of the items 
std::vector<int> foo (3,100);   // three ints with a value of 100
std::vector<int> bar (5,200);   // five ints with a value of 200

  foo.swap(bar);
result:
-----------
foo contains: 200 200 200 200 200 
bar contains: 100 100 100 

7) d.clear() // Clears the content of the vector with no gurentee of the aloctaion  



Element access:
----------------
// assign some values:
  for (unsigned i=0; i<myvector.size(); i++)
    myvector.at(i)=i;
Access first/last element
Returns a reference to the first/last element in the vector.
Unlike member vector::begin/end, which returns an iterator just past this element, this function returns a direct reference
myvector.back()
myvector.front()

Capacity:
----------------
4) d.resize(5) // resizee the vector its current size = 5 
Resizes the container so that it contains n elements.
myvector.resize(8,100);

5) Their is no find function in vector

6)  vector<int> *p= new vector<int>(6);
    p->resize(7); as vectors grows by size the fuctionality is shown by capacity


for (int i=0; i<100; i++) myvector.push_back(i);

  std::cout << "size: " << myvector.size() << "\n"; // show the filled size with elemnts
  std::cout << "capacity: " << myvector.capacity() << "\n";  // Actual allocation it grows by a power of 2 when the previous elents are filled ... 2.4.8.16....
  std::cout << "max_size: " << myvector.max_size() << "\n";/ amx possible size
o/p:
size: 100
capacity: 128
max_size: 107374182

d.size() ; 
d.capacity().

check for empty

while (!myvector.empty())
  {
     sum += myvector.back();
     myvector.pop_back();
  }
  
  Sets the cpapacity of the vecot to 100 not 128which it would automatically take
  bar.reserve(100);
  
  
8) 2d vectors :
----------------------------------
vector <vector<char> > my_2D_vector;

my_2D_vector.resize(4); //since you want 4 rows

//now fill first row with data
my_2D_vector[0].push_back('1'); //I'm not sure if you want '1' to actually be part of the data
my_2D_vector[0].push_back('a');
my_2D_vector[0].push_back('b');

--------------
1, a, b, c
2, d, e, f

-----------------------------------------------------------------------------------------------------------------------------
Iterators:

const_iteratoer means that within the iterator the container is const and
all of its elements are const. With a const_iterator you can neither modify
the container(add/remove elements) nor can you modify the elements in that
container. The advantage of the const_iterator is that the compiler
produces faster code when you use it. So you should use the const_iterator
whenever you iterate over the container without modifying anything.

***********************************************************************************
List
Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence,
and iteration in both directions.List containers are implemented as doubly-linked lists; Doubly linked lists can
store each of the elements they contain in different and unrelated storage locations.

Adv:
-----------------------
Compared to other base standard sequence containers (array, vector and deque), lists perform generally better in 
inserting, 
extracting 
moving elements in any position within the container for which an iterator has already been obtained,
and therefore also in algorithms that make intensive use of these, like sorting algorithms.

Disadv:
-----------------------
The main drawback of lists and forward_lists compared to these other sequence containers is that they lack direct 
access to the elements by their position; For example, to access the sixth element in a list, one has to iterate from 
a known position (like the beginning or the end) to that position.

Container properties
-----------------------
Sequence
Elements in sequence containers are ordered in a strict linear sequence. Individual elements are accessed by their position in this sequence.
Doubly-linked list
Each element keeps information on how to locate the next and the previous elements, allowing constant time insert and erase operations before or after a specific element (even of entire ranges), but no direct random access.
Allocator-aware
The container uses an allocator object to dynamically handle its storage needs.

List Creation:
==============
Constructor are ditto as Vectors al five types

Iterators:
--------------
All are common to vectors except 

1) rbegin/rend:
=================
for (std::list<int>::reverse_iterator rit=mylist.rbegin(); rit!=mylist.rend(); ++rit)
    std::cout << ' ' << *rit;
	
Capacity:
--------------
empty , size , maxsize
same implemented as vector

Modifiers:
-----------------
All oters are same and this new two are dded 
pushfront/popfront
Value added/deleted in the front and increases or reduces size of the list 


Operations:
-----------

Spliceing in Lists:
Transfers elements from x into the container, inserting them at position.
This effectively inserts those elements into the container and removes them from x, 
altering the sizes of both containers. The operation does not involve the construction or 
destruction of any element. They are transferred, no matter whether x is an lvalue or an
rvalue, or whether the value_type supports move-construction or no

 mylist1: 1 2 3 4
 mylist2: 10 20 30
 
 it = mylist1.begin();
  ++it;                         // points to 2

  mylist1.splice (it, mylist2); // mylist1: 1 10 20 30 2 3 4
                                // mylist2 (empty)
                                // "it" still points to 2 (the 5th element)

								
	mylist2.splice (mylist2.begin(),mylist1, it);
                                // mylist1: 1 10 20 30 3 4
                                // mylist2: 2
                                // "it" is now invalid.
  it = mylist1.begin();
  std::advance(it,3);           // "it" points now to 30

  mylist1.splice ( mylist1.begin(), mylist1, it, mylist1.end());
                                // mylist1: 30 3 4 1 10 20
								
Remove:
------------
Removes from the container all the elements that compare equal to val. This calls the destructor
 of these objects and reduces the container size by the number of elements removed.

 mylist1.remove(20); // mylist1: 30 3 4 1 10 
 
 
Unique:
------------
Remove duplicate values
The version with no parameters (1), removes all but the first element from every consecutive group of equal elements in the container.

Notice that an element is only removed from the list container if it compares equal to the element immediately preceding it. Thus, 
this function is especially useful for sorted lists.

// a binary predicate implemented as a function:
bool same_integral_part (double first, double second)
{ return ( int(first)==int(second) ); }

// a binary predicate implemented as a class:
struct is_near {
  bool operator() (double first, double second)
  { return (fabs(first-second)<5.0); }
};
	mylist.sort();             //  2.72,  3.14, 12.15, 12.77, 12.77,
	mylist.unique();           //  2.72,  3.14, 12.15, 12.77
	mylist.unique (same_integral_part);  //  2.72,  3.14, 12.15
	mylist.unique (is_near());           //  2.72, 12.15, 72.25
   								
  

merge:
-----------
1,2,72
3,5,5

first.merge(second);
1,2,3,5,5,72
// (second is now empty)



reverse :
--------------\
This reverses the current list and the current list is a reverese list now
  mylist.reverse();
<int>::iterator fiveagain =  find( numbers.begin(), numbers.end(), 5 );
 // find the position of the number 5 in the list, O(n), but does not depend on the list being sorted

3) // erase all the elements greater than 4
        numbers.erase( remove_if(numbers.begin(), numbers.end(),
                                                         bind2nd(greater<int>(), 4) ), numbers.end() );
4) String insertion in a list 
string s("There is no distinctly nativ"
  list<char> list1(s.begin(), s.end());
5) U cannot use list1[i++ ] only iterarors should be used to parse up each elementso to insert a data suppose on 3rd elemnt 
list<int>::iterator  itr = l.begin();
advance(itr , 2); //incremnt the itr to 3rd elemnt
*itr = 45; // vaue assign

   
Code :(Use of Sort )
******************
 
int main()
{
string
array[] =
{
"charley",
"alpha",
"bravo",
"alpha"
};
list<string> target(array, array + sizeof(array)/ sizeof(string));
cout << "Initially we have:\n";showlist(target);
                target.sort();
cout << "After sort() we have:\n";showlist(target);
                target.unique();
cout << "After unique() we have:\n";
showlist(target);
}
/*
Generated output:
Initially we have:
charley alpha bravo alpha
After sort() we have:
alpha alpha bravo charley
After unique() we have:
alpha bravo charley
*/
unordered containers support the following basic set of operators:
***************************************************************************************************
• The overloaded assignment operator, so we can assign two containers of the same types to each
other. This basic operator is supported by the unordered containers;
• Tests for equality: == and != The equality operator applied to two containers returns true if
the two containers have the same number of elements, which are pairwise equal according to
the equality operator of the contained data type. The inequality operator does the opposite;
• Ordering operators: <, <=, > and >=. The < operator returns true if each element in the lefthand
side container is less than each corresponding element in the right-hand side container.
Additional elements in either the left-hand side container or the right-hand side container are
ignored.
container left;
container right;
left = {0, 2, 4};
right = {1, 3}; // left < right
right = {1, 3, 6, 1, 2}; // left < right
Note that before a user-defined type (usually a class-type) can be stored in a container, the userdefined
type should at least support:
• A default value (e.g., a default constructor)
• The equality operator (==)
• The less-than operator (<)

----------------------------------------------------------------------------------------------------------------------
Set 
an ordered collection, the standard library set data structure is always ordered. Its functionality in 
the STL is provided as a template class,such that any valid C++ object can be used with it.

Its usually used for a Binary sorted list but wer the search time is in logO values its much lesser den list n all
//For the List instialisation of a set 
list<char>::iterator i;
 for (i = list1.begin(); i != list1.end(); ++i)
    set1.insert(*i);
The o/p of the set when displaye will b e a binary sorted key .

map with a specific order rest all are same as map 




Multiset:
-----------
Multiple-key set
Multisets are containers that store elements following a specific order, and where multiple elements can have equivalent values.

In a multiset, the value of an element also identifies it (the value is itself the key, of type T). The value of the elements in 
a multiset cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the 
container.

rest are same as set 



---------------------------
Map:
--------------
Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion
indicated by its internal comparison object (of type Compare). map containers are generally slower than unordered_map 
containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.
The mapped values in a map can be accessed directly by their corresponding key using the bracket operator ((operator[]).

Maps are typically implemented as binary search trees.
The elements are sorted according to the comparison object. If more than one element with equivalent keys is passed to the
constructor, only the first one is preserved.




Observers:
key_comp
------------------
The comparison object of a map object is set on construction. Its type (member key_compare) is the third template parameter 
of the map template. By default, this is a less object, which returns the same as operator<.
//Lets declare the key_comp 
std::map<char,int>::key_compare mycomp = mymap.key_comp();

  mymap['a']=100;
  mymap['b']=200;
  mymap['c']=300;

  std::cout << "mymap contains:\n";

  std::map<char,int>::iterator it = mymap.begin();
  do {
    std::cout << it->first << " => " << it->second << '\n';
  } while ( mycomp((*it++).first, 'c') );


value_comp
------------------
Return value comparison object (public member function )


Operations:
-----------------

find:
-----
Get iterator to element Searches the container for an element with a key equivalent to k and returns an 
iterator to it if found, otherwise it returns an iterator to map::end.

 it = mymap.find('b');
  if (it != mymap.end())
    mymap.erase (it);
	
Count	
Count elements with a specific key Searches the container for elements with a key equivalent to k and returns
the number of matches. Because all elements in a map container are unique, the function can only return 1
 (if the element is found) or zero (otherwise).

std::cout << c;
    if (mymap.count(c)>0)

Upper/lower Bound
-----------------
itlow=mymap.lower_bound ('b');  // itlow points to b
  itup=mymap.upper_bound ('d');   // itup points to e (not d!)

  mymap.erase(itlow,itup);        // erases [itlow,itup)
  
  

1) inserting elemetns
***********************************
// 1) Assignment using array index notation
Employees["Mike C."] = 5234;
Employees["Charlie M."] = 3374;

// 2) Assignment using member function insert() and STL pair
Employees.insert(std::pair<string,int>("David D.",1923));

// 3) Assignment using member function insert() and "value_type()"
Employees.insert(map<string,int>::value_type("John A.",7582));

// 4) Assignment using member function insert() and "make_pair()"
Employees.insert(std::make_pair("Peter Q.",5328));


2) char *i ;
                                map<int,string>::const_iterator itr= m1.begin();
                                i = m1.find(data)->second; // find returns n iterator
3)  MapType::iterator iter = my_map.begin();

    // erase the first element using the erase function
    my_map.erase(iter);
	
	
int main()
{ 
    
    map<string,string> m1;
    m1.insert(make_pair("test1","1stElement"));
    m1.insert(pair<string,string>("test2","2ndElment"));
    m1["test3"] = "3rdElement";
    m1.insert(map<string,string>::value_type("test4","4thElement"));
    m1["test3"] = "3rdElement";
    
    map<string,string>::const_iterator itr = m1.begin();
     for(;itr != m1.end();itr++)
        cout<<" itr ="<<itr->first<<"2nd elemnt" << itr->second <<endl;
    
    
  // cout<< m1.find("yacck")->second;
   cout<< m1.upper_bound("test2")->second<<endl; // next element
   cout<< m1.lower_bound("test2")->second;// lower points towards the same elmnt
    
    //Count of all elements
    cout<<"Count" << m1.count("test3"); // if the elemnt is their then 1
    itr = m1.find("test3")->second<<endl;
    
    int main()
{ 
    
    map<string,string> m1;
    m1.insert(make_pair("test1","1stElement"));
    m1.insert(pair<string,string>("test2","2ndElment"));
    m1["test3"] = "3rdElement";
    m1.insert(map<string,string>::value_type("test4","4thElement"));
    m1["test3"] = "3rdElement";
    
    map<string,string>::const_iterator itr = m1.begin();
     for(;itr != m1.end();itr++)
        cout<<" itr ="<<itr->first<<"2nd elemnt" << itr->second <<endl;
    
    
  // cout<< m1.find("yacck")->second;
   cout<< m1.upper_bound("test2")->second<<endl; // next element
   cout<< m1.lower_bound("test2")->second;// lower points towards the same elmnt
    
    //Count of all elements
    cout<<"Count" << m1.count("test3"); // if the elemnt is their then 1
    itr = m1.find("test3")->second<<endl;
    int main()
{ 
    
    map<string,string> m1;
    m1.insert(make_pair("test1","1stElement"));
    m1.insert(pair<string,string>("test2","2ndElment"));
    m1["test3"] = "3rdElement";
    m1.insert(map<string,string>::value_type("test4","4thElement"));
    m1["test3"] = "3rdElement";
    
    map<string,string>::const_iterator itr = m1.begin();
     for(;itr != m1.end();itr++)
        cout<<" itr ="<<itr->first<<"2nd elemnt" << itr->second <<endl;
    
    
  // cout<< m1.find("yacck")->second;
   cout<< m1.upper_bound("test2")->second<<endl; // next element
   cout<< m1.lower_bound("test2")->second;// lower points towards the same elmnt
    
    //Count of all elements
    cout<<"Count" << m1.count("test3"); // if the elemnt is their then 1
    itr = m1.find("test3")->second<<endl;
     //Count of all elements
    cout<<"Count" << m1.count("test3"); // if the elemnt is their then 1
    itr = m1.find("te");
    
    if(itr == m1.end())
    cout<<"not found";
    
   
   
   return 0;
}
    
   
   
   return 0;
}
   
   
   return 0;
}
	
	
Multimap:
------------------
is a generalization of a map or associative array abstract data type in which more than one value may be
 associated with and returned for a given key.
 Both map and multimap are particular cases of containers . 
 
1) Insertion 
 multimap< int, double, less< int > > pairs; // declare the multimap pairs

   // insert two value_type objects in pairs
   pairs.insert(  multimap< int, double,less< int > >::value_type( 15, 2.7,) );

-----------------------------------------------------------------------------------------------------------------------------


PRIORITY QUEUE:
=====================
The priority Queue is a datastructure which is used to maintain the SRT(Shortest Reamining process time: When scheduler checks
 the process on base o the 
priority , the process whic has less completion time gets the higher priority So the scheduler stops a running low priority process and run the 
recent high priority and then it agin calls the low priority process to run)

Priority Queue will have a Pririty associated with data type 
Operations it supports:
1. Insert
2. MinLowestPriority (Lowest priority is removed )
3. deleteMinPriority(returns and delete the lowest element)

memeber:
Comparator(when PQ needs to compare two elemnts ut calls compare, the compare gives the freedom to PQ to hold any kind of 
elemtns)

insertion in PQ:
-------------------------
If we keep ithe prority elements in a Binary sorted tree the insert and the search is going to take  Time = o(logn) which is fixed for any number of elemet


--------------------------------------------------------------------------------
Valarray class
A valarray object is designed to hold an array of elements, and easily perform mathematical operations on them. 
It also allows special mechanisms to create subsets of the arrays, using its operator[] .




#include <valarray>


int main ()
{
  valarray<int> foo (12);  //Declare an array of 12 elemnts
  for (int i=0; i<12; ++i) foo[i]=i; // initialise 
  slice sm ; //obj of slice
  
  
  valarray<int> bar = foo[slice(2,3,4)]; // from 2 elemt with stride 4 collect 3 members use [] as Slice in valarray
   // members are 2 6 10
  sm = slice(2,3,4); // sli obj intilisaion wd a slicce
  foo[sm ] *= valarray<int>(10,3); // multiply the slice members 
    
  
  for (size_t n=0; n<bar.size(); n++)
	  cout << bar[n] << ' ';
  cout << endl;

  return 0;


--------------------------------------------------------------------------------


-----------------------------------------------------------------------------
 class deque;
the deque is the queue LIFO can be done from both sides
The following functionalities are available:

Iterators:
*****************
begin	 Return iterator to beginning (public member function)
end	 Return iterator to end (public member function)
rbegin Return reverse iterator to reverse beginning (public member function)
rend

push_back()
push_front()
pop_back()
pop_front 

It can be considered as a dobly link llist

-------------------details of STL----------------------------------------------------
Containers
====================
The STL provides different kinds of containers which are all formulated as template
classes. Containers are objects which are used to manage other objects, where it is
left to the user to decide whether the objects are deposited by value or by reference.


A means of making different algorithms work with different containers is to
choose the same names (which are evaluated at compile time) for similar operations.
The method size(), for example, returns the number of elements in a container,
no matter whether it is of vector, list, or map type. Other examples are the
methods begin() and end() which are used to determine the position of the first
element and the position after the last element.



Iterators
====================
Iterators work like pointers. Depending on the application, they can be common
pointers or objects with pointer-like properties. Iterators are used to access container
elements. They can move from one element to the other, with the kind of movement
being hidden to the outside (control abstraction).


Algorithms
==========================
The template algorithms work with iterators that access containers. Since not only
user-defined data types, but also the data types already existing in C++, such as int,
char, and so on are supported, the algorithms have been designed in such a way that
they can also work with normal pointers .

Interplay
============================
Containers make iterators available, algorithms use them:
Containers <----->() Iterators ()<---------> Algorithms
This leads to a separation which allows an exceptionally clear design. In the
following example, variations of one program will be used to show that algorithms
function just as well with C arrays as with template classes of the STL.

#include<iostream> // see Section 1.7.2 for header conventions
using namespace std;
// new type name IteratorType for pointer to const int
// (we don’t want to modify the values here)
typedef const int* IteratorType;
// prototype of the algorithm
	IteratorType find(IteratorType begin, IteratorType end,const int& Value);
	int main() {
		const int Count = 100;
		int aContainer[Count]; // define container
		IteratorType begin = aContainer; // pointer to the beginning
		// position after the last element
		IteratorType end = aContainer + Count;
		// fill container with even numbers
		for(int i = 0; i < Count; ++i)
			aContainer[i] = 2*i;
		int Number = 0;
		while(Number != -1) {
			cout << " enter required number (-1 = end):";
			cin >> Number;
			if(Number != -1) { // continue?
				IteratorType position = find(begin, end, Number);
				if (position != end)
					cout << "found at position "<< (position - begin) << endl;
				else
					cout << Number << " not found!" << endl;
			}
		}
	}
// implementation
IteratorType find(IteratorType begin, IteratorType end,const int& Value) {
	while(begin != end // pointer comparison && *begin != Value) // dereferencing and object comparison
		++begin; // next position
	return begin;
}

// variation 2: algorithm as template 
// new type name IteratorType for pointer to const int
// (we don’t want to modify the values here)
typedef const int* IteratorType;

typedef vector<int>::const_iterator IteratorType;
// algorithm as template
template<class Iteratortype, class T> 
Iteratortype find(Iteratortype begin, Iteratortype end,const T& Value)
 {
	while(begin != end // iterator comparison   
	&& *begin != Value) // object comparison
		++begin; // next position
	return begin;
}


int main() {
	const int Count = 100;
	vector<int> aContainer(Count); // define container
	for(int i = 0; i < Count; ++i) // fill container with
		aContainer[i] = 2*i; // even numbers
	int Number = 0;
	while(Number != -1) {
		cout << " enter required number (-1 = end):";
		cin >> Number;
		if(Number != -1) {
			// use global find() defined above
			IteratorType position = ::find(aContainer.begin(),aContainer.end(), Number);
		if (position != aContainer.end())
			cout << "found at position "
		}
		
Pairs
A pair in the sense of the STL is an encapsulation of two objects which belong
together and which can be of different types.

template <class T1, class T2>
struct pair {
	T1 first;
	T2 second;
	pair(){}; // see text
	// initialize first with x and second with y:
	pair(const T1& x, const T2& y);
	// copy constructor:
	template<class U, class V> pair(const pair<U, V> &p);
};

The default constructor causes the elements to be initiated with the default constructors
of their type. In addition to the class definition, there are some comparison
operators:
template <class T1, class T2>
bool operator==(const pair<T1, T2>& x,const pair<T1, T2>& y) {
	return x.first == y.first && x.second == y.second;
}

template <class T1, class T2>
bool operator<(const pair<T1, T2>& x,const pair<T1, T2>& y) {
	return x.first < y.first || (!(y.first < x.first) && x.second < y.second);
}

Explaination : 
When the first objects are equal, the return value of the < operator is determined
by the comparison of the second objects. However, in order to make only minimum
demands on the objects, the equality operator == is not used in the second template.and (!(y.first < x.first)
if y.first is only greater then it will return 1
It might be the case that equality of two pairs is not required in a program.

template <class T1, class T2>
bool operator!=(const pair<T1, T2>& x,const pair<T1, T2>& y);

template <class T1, class T2>
bool operator> (const pair<T1, T2>& x,const pair<T1, T2>& y);

template <class T1, class T2>
bool operator>=(const pair<T1, T2>& x,const pair<T1, T2>& y);

template <class T1, class T2>
bool operator<=(const pair<T1, T2>& x,const pair<T1, T2>& y);

A function facilitates the generation of pairs:
template <class T1, class T2>
pair<T1, T2> make_pair(const T1& x, const T2& y) {
	return pair<T1, T2>(x, y);
}

Function objects:
=======================

A object can be called in the same way as a function. Algorithmic objects
of this kind are called function objects or functors.
Functors are objects which behave like functions but have all the properties of
objects. They can be generated, passed as arguments, or have their state modified.
The change of state allows a flexible application which, with functions, would be
only possible via additional parameters.

Comparisons:
=======================
The STL provides a large number of template classes for comparisons. Objects of
this class appear later under the name of comparison object.

template<class Arg1, class Arg2, class Result>
struct binary_function {
	typedef Arg1 first_argument_type;
	typedef Arg2 second_argument_type;
	typedef Result result_type;
};
For unary classes, a corresponding template unary_function is defined. The
word struct saves the public label. Everything can be public, because the class
has no data to be protected. This, for example, is the equal_to template for equality:
	template<class T>
	struct equal_to : binary_function<T, T, bool> {
		bool operator()(const T& x, const T& y) const {
			return x == y;
		}
	};

***Now lets use struct this as template Type to do a functional test, So we can pass any Algo
like that as a functor to a single function shown below
template<class T, class CompareType>
void bubble_sort(T* array, int Count,const CompareType& Compare) {
	for(int i = 0; i < Count; ++i) {
		for(int j = i+1; j < Count; ++j)
			if (Compare(array[i], array[j])) { // functor call
			// exchange
				const T temp = array[i];
				array[i] = array[j];
				array[j] = temp;
			}
		}
	}
// Auxiliary procedure for display
void Display(int *Array, int N) {
	for(int i = 0; i < N; ++i) {
		std::cout.width(7);
		std::cout << Array[i];
   	}
	std::cout << std::endl;
}

Function adapters
==========================
Function adapters are nothing more than function objects which cooperate with other
function objects to adapt them to different requirements. This allows us to get by with
existing functors and avoid writing new ones.
not1
The function not1 takes a functor as the parameter which represents a predicate
with one argument (thus the suffix 1) and returns a functor which converts the return type to a 
opposite one 
Example: 
Lets consider a function which is just a unary function 
struct odd : public unary_function<int, bool> {
	bool operator () (int x) const {
	return (x % 2) != 0;
	}
};

use odd : odd()(2)  # False
Now lets use not1 which takes this funcyor as an argument and negate its outcome 

not1(odd())(2)  # True
not1 generates
a functor whose operator () is called with the argument i. How does this work? The
STL provides a class out of which not1 generates an object:

template <class Predicate>
class unary_negate : public unary_function<typename Predicate::argument_type, bool> {
	
	protected:
		Predicate pred;
	public:
		explicit unary_negate(const Predicate& x) : pred(x) {}
		bool operator()(const typename Predicate::argument_type& x) const {
			return !pred(x);
		}
};

bind1st, bind2nd
These functions transform binary function objects into unary function objects by
binding one of the two arguments to a value. They accept a function object with
two arguments and a value x. They return a unary function object whose first or
second argument is bound to the value x.

Example :
std::find(v.begin(), v.end(),std::bind2nd(std::less<int>(), 1000));
finds the first number in the int vector v which is less than 1000,

std::find(v.begin(), v.end(),std::bind1st(std::less<int>(), 1000));
finds the first number in the int vector v which is greater than 1000


Iterators :
==========================
 iterators closely cooperate with containers. 
// scheme of a simple iterator:
template<class T>
	class Iterator {
		public:
		// constructors, destructor ....
		bool operator==(const Iterator<T>&) const;
		bool operator!=(const Iterator<T>&) const;
		Iterator<T>& operator++(); // prefix
		Iterator<T> operator++(int); // postfix
		T& operator*() const;
		T* operator->() const;
	private:
		// association with the container ...
};

States olf iterators
========================================
Iterators are a generalization of pointers. They allow you to work with different
containers in the same way. An iterator can assume several states.
• An iterator can be generated even without being associated with a container. The
association with the container is then made at a later stage. Such an iterator cannot
be dereferenced. A comparable C++ pointer could, for example, have the value 0.
• An iterator can be associated with a container during generation or at a later stage.
Typically – but not compulsorily – after initialization it points to the beginning of
the container. The method begin() of a container supplies the starting position.
If the container is not empty, the iterator can in this case be dereferenced. Thus,
it can be used to access an element of the container. With the exception of the
end() position (see next point) the iterator can be dereferenced for all values that
can be reached with the ++ operation.
• In C++ the value of a pointer which points to a position directly past the last
element of a C array is always defined. Similarly, the method end() of a container
always returns an iterator with exactly this meaning, even if the container is not
an array but, for example, a list.


advance()
----------------
In order to advance an iterator by a given distance, the function advance() can be
used:
template<class InputIterator_type, class Distance_type>
void advance(InputIterator_type& I, Distance_type N);
The iterator I is advanced by N steps. For iterators that can move forward and


Categories
----------------
The STL provides different iterators for the container in question. Each of these
iterators can be assigned to one of the following five categories:
• input iterator
• output iterator
• forward iterator
• bidirectional iterator
• random access iterator
* Reverse iterators
	A reverse iterator is always possible with a bidirectional iterator. A reverse iterator
	moves backward through a container by way of the ++ operation.
*Const iterators
	The standard containers also provide iterators of the type const_iterator and
	const_reverse_iterator. These iterators are comparable to a pointer to const,
	e.g. const char*: they are not const but cannot be used to modify an element
	backward (bidirectional iterators) N may be negative.
Stream iterators
	Stream iterators are used to work directly with input and output streams. The following
	sections show how stream iterators are employed for reading and writing
	sequential files.
---------------------------------------------------------------------
----------------------------------------------------------------------
template<class T>
class slist {
	public:
	/*Some types of the class get public names. Then it is possible to use them outside
	the class without knowing the implementation.
	*/
		typedef T value_type;
		typedef ptrdiff_t difference_type;
		typedef T* pointer;
		typedef T& reference;
	// etc. see text
		slist() : firstElement(0), Count(0) {}
/*copy constructor, destructor and assignment operator are omitted! The implementation
of push_front() creates a new list element and inserts it at the beginning
of the list:
*/
		void push_front(const T& Datum) { // insert at beginning
			firstElement = new ListElement(Datum, firstElement);
			++Count;
		}
	private:
		struct ListElement
		{
			T Data;
			ListElement *Next;
			ListElement(const T& Datum, ListElement* p): Data(Datum), Next(p) {}
		};
		ListElement *firstElement;
		size_t Count;
public: class iterator {
	public:
		typedef std::forward_iterator_tag iterator_category;
		typedef T value_type;
		typedef T* pointer;
		typedef T& reference;
		typedef size_t size_type;
		typedef ptrdiff_t difference_type;
		iterator(ListElement* Init = 0): current(Init){}

		T& operator*() { // dereferencing
			return current->Data;
		}
		const T& operator*() const { // dereferencing
			return current->Data;
		}
		iterator& operator++() { // prefix
			if(current) // not yet arrived at the end?
				current = current->Next;
			return *this;
		}
		iterator operator++(int) { // postfix
			iterator temp = *this;
			++*this;
			return temp;
		}
		
		bool operator==(const iterator& x) const {
			return current == x.current;
		}
		
		bool operator!=(const iterator& x) const {
			return current != x.current;
		}
	private:
		ListElement* current; // pointer to current element
}; // iterator


template<class Iterator>
Iterator::difference_type operator-(Iterator second,Iterator first)
{
	Iterator::difference_type count = 0; // type maybe int
/*The difference between the iterators is determined by incrementing first until the
second iterator is reached. Thus, the condition is that first lies not after the second
iterator. In other words: second must be able to reach the iterator by means of the
++ operator.
*/
	while(first != second && first != Iterator()) {
		++first;
		++count;
	}
	// In case of inequality, second is not reachable by first
	assert(first == second);
	return count;
}

if(Number != -1) {
// use of container methods:
	br_stl::slist<int>::iterator Position =	std::find(aContainer.begin(),aContainer.end(), Number);
	if(Position != aContainer.end())
		std::cout << "found at position "<< (Position - aContainer.begin())<< std::endl;
	else
		std::cout << Number << " not found!"<< std::endl;
}

Containers 
========================================
Summary: A container is an object that is used to manage other objects which in this
context are called elements of the container. It deals with allocation and deallocation
of memory and controls insertion and deletion of elements.

In part, the STL containers are typical implicit data types in 
They include vector, list, and deque.

Other containers, in contrast, are abstract data types which are implemented by means of the implicit data types. 
These include
stack, queue, and priority_queue.

Further abstract data types are 
set, map, multiset, and multimap. 
They are implemented by means of so-called red-black trees


Data type interface
--------------------------------
Each container provides a public set of data types that can be used in a program. The
data type vector<int>::iterator . It can be identical to a pointer type such as int*, but this is not compulsory.
The aim of data types is to ensure that the interface to a container in a program
is unique at compile time.
container data types required for user-defined containers and already provided by the containers of the STL
Data typ		 Meaning
X::value_typ		 T
X::reference 		reference to container element
X::const_reference 	ditto for read-only purposes
X::iterator 		type of iterator
X::const_iterator 	ditto, but cannot be used to modify an element
X::difference_typ	 signed integral type (see distance type, page 32)
X::size_typ		 unsigned integral type for size specifications

Container methods
--------------------------------
Each container provides a public set of methods which can be used in a program.
The methods begin() and end()

An example of the swap() method can be found A vector<int> with a 16-bit size_t
can contain at most 32 767 elements. The current size, returned by the size() function,
results from the distance between beginning and end, as calculated by the function
distance(a.begin(), a.end(), n)
Reversible containers
--------------------------------
Reversible containers allow iterators to traverse backward. Such iterators may be
bidirectional and random access

Return type method 			Meaning
X() 					default constructor; creates empty container
X(const X&) 				copy constructor
~X() 					destructor; calls the destructors for all elements of the container
iterator begin() 			beginning of the container
const_iterator begin() 			beginning of the container
iterator end(				 position after the last element
const_iterator end() 			ditto
size_type max_size() 			maximum possible container size (see text)
size_type size() 			current size of the container (see text)
bool empty() size() == 0 or begin() == end()
void swap(X&) 				swapping with argument container
X& operator=(const X&) 			assignment operator
bool operator==(const X&) 		operator ==
bool operator!=(const X&		 operator !=
bool operator<(const X&)		 operator <
bool operator>(const X&) 		operator >
bool operator<=(const X&		 operator <=
bool operator>=(const X&) 		operator >=


X::reverse_iterator
X::const_reverse_iterator
and the methods
rbegin() // points to last element
rend() // points to fictitious position before the first element


Sequences
========================================
A sequence is a container whose elements are arranged in a strictly linear way Notation for intervals
It is frequently necessary to specify intervals. For this purpose, the usual mathematical
interval is used, where square brackets denote intervals including the boundary
values, and round parentheses denote intervals excluding the boundary values. Thus,
[i, j) is an interval including i and excluding j. sequential container; i and j are of input iterator type; p and q are dereferenceable
iterators; n is of type X::size_type and t is an element of type X::value_type.

Return type metho		 Meaning
X(n, t				 Creates a sequence of type X with n copies oft.
X(i, j				 Creates a sequence with the elements of the
range [i, j) 			copied into the sequence.
iterator insert(p, t) 		Copies a copy of t before the location p. The return value points to the inserted copy.
void insert(p, n, t		 Copies n copies of t before the location p.
void insert(p, i, j) 		Copies the elements of the range [i, j) beforethe location p. i, j refer to another container
				than that for which insert() is called.
iterator erase(q) 		Deletes the element pointed to by q. The returned
				iterator points to the element immediately
				following q prior to the deletion operation,
				provided it exists. Otherwise, end() is
				returned.
iterator erase(q1, q2) 		Deletes the elements of the range [q1, q2).

void clear() 			Deletes all elements; corresponds to erase(begin(), end()).


The STL contains three kinds of sequential containers, namely vector, list,
and deque. A list (list) should be used when frequent insertions and deletions are
needed somewhere in the middle. A queue with two ends (deque = double ended
queue) is reasonable when insertion and deletion frequently take place at either end.
vector corresponds to an array. deque and vector allow random access to elements.
The above-mentioned operations together with their containers need only constant
time. Other

for comparison, where Container can be one of the types vector, list or deque.
In addition to the data types of Table 3.1, the types of Table 3.4 are provided.
Data type Meaning
X::pointer pointer to container element
X::const_pointer ditto, but cannot be used to modify container elements


Vector
========================================
Now that all essential properties of a vector container have been described, let us
look at some examples of its application. First, a vector with 10 places is filled with
the numbers 0 to 9. At the end, the number 100 is appended,

#include<vector>
#include<iostream>
using namespace std;
int main() {
	// an int vector of 10 elements
	vector<int> intV(10);
	for(size_t i = 0; i < intV.size(); ++i)
	intV[i] = i; // fill vector, random access
	// vector increases on demand
	intV.insert(intV.end(), 100); // append the number 100
	// use as array
	for(size_t i = 0; i < intV.size(); ++i)
	cout << intV[i] << endl;
	// use with an iterator
	for(vector<int>::iterator I = intV.begin();
		I != intV.end(); ++I)
	cout << *I << endl;


Return type method 			Meaning
void assign(n, t = T()) 		Deletes the container elements
					and subsequently inserts n elements
					t.
void assign(i, j) 			Deletes the container elements
					and subsequently inserts the elements
					of the iterator range [i,j).
reference front(			 Supplies a reference to the first element of a container.
const_reference front() 		Ditto, but cannot be used to modify container elements.
reference back() 			Supplies a reference to the last element of a container.
const_reference back() 			Ditto, but cannot be used to modify container elements.
void push_back(t) 			Inserts t at the end.
void pop_back() 			Deletes the last element.
void resize(n, t = T()) 		Changes the container size. n -size() elements t are inserted at
					the end or size()-n elements are
					deleted at the end, depending on
					whether n is greater or less than the current size.
reverse_iterator rbegin() 		Returns the begin iterator for backward traversal. This iterator
					points to the last element.
const_reverse_iterator rbegin() 	Ditto, but cannot be used to modify container elements.
reverse_iterator rend(			 Returns the end iterator for backward traversal.
const_reverse_iterator rend() 		Ditto, but cannot be used to modify, container elements.

//swap() from Table 3.2 shows a very fast method for
// swapping two vectors.
newV.swap(intV);
cout << "\n newV after swapping = ";
for(size_t i = 0; i < newV.size(); ++i)
	cout << newV[i] << ’ ’; // old contents of intV
	cout << "\n\n intV = ";
for(size_t i = 0; i < intV.size(); ++i)
	cout << intV[i] << ’ ’; // old contents of newV
	cout << endl;
}

how an element is deleted which leads to a change in the number of elements. All
elements following the deleted element shift by one position. This process is a timeconsuming
operation. Finally, a reverse_iterator is used which traverses the container backward.
#include<vector>
#include<iostream>
#include<string>
using namespace std;
int main() {
// a string vector of 4 elements
	vector<string> stringVec(4);
	stringVec[0] = "First";
	stringVec[1] = "Second";
	stringVec[2] = "Third";
	stringVec[3] = "Fourth";
	
	// vector increases size on demand
	stringVec.insert(stringVec.end(), string("Last"));
	cout << "size() = "
	<< stringVec.size() << endl; // 5
	// delete the element ‘Second’
	vector<string>::iterator I = stringVec.begin();
	++I; // 2nd position
	cout << "erase: "
	<< *I << endl;
	stringVec.erase(I); // delete Second
	cout << "size() = "
	<< stringVec.size() << endl; //
	
	for(I = stringVec.begin(); I != stringVec.end(); ++I)
		cout << *I << endl;
/* Output: First
Third
Fourth
Last
*/
cout << "backwards with reverse_iterator:" << endl;
for(vector<string>::reverse_iterator
revI = stringVec.rbegin(); revI != stringVec.rend();
++revI)
cout << *revI << endl;
} // main.cpp

On average, deletion or insertion of an element at the end of a vector takes constant
time, that is O(1) in complexity notation (for example, pop_back()). Insertion
or deletion of an element somewhere in the middle takes a time proportional

List
===========================================================================================
 It makes use of the Identifier class described there, with
the difference that the identifiers are not written into a file, but into a list which is
subsequently displayed:
// k3/list/identify/main.cpp
#include<iterator>
#include<fstream>
#include<list>
#include"identif.h"
int main( ) {
// define and open input file
	std::ifstream Source("main.cpp");
	std::list<Identifier> Identifier_list;
	std::istream_iterator<Identifier> iPos(Source), end;

Return type method Meaning
reference operator[](n) Returns a reference to the nth element
(usage: a[n], when a is the container).
	const_reference operator[](n) Ditto, but cannot be used to modify
container elements.
reference at(n) Checks if n is within the valid range.
If yes, a reference to the nth element
is returned, otherwise an exception is
thrown.
	const_reference at(n) Ditto, but cannot be used to modify
container elements.
void reserve(n) Reserves memory space, so that the
	available space (capacity) exceeds the
	currently needed space. 
	
	Aim: avoiding memory allocation operation during vector use.size_type capacity() Returns the capacity value (see
reserve()). size() is always less
than or equal to capacity().
Table 3.6: Additional vector methods.
if(iPos == end)
	std::cout << "File not found!" << std::endl;
else
while(iPos != end)
// insert identifier and read next one
	Identifier_list.push_back(*iPos++);
// output
std::list<Identifier>::const_iterator
I = Identifier_list.begin();
while(I != Identifier_list.end())
	std::cout << *I++ << std::endl;
}
The structure of the main() programs resembles the one on page 43. This resemblance
facilitates learning how to use iterators and containers. In contrast to the
vector, insert() and erase() do not invalidate iterators that point to elements of
the list, with the exception of an iterator that points to an element to be deleted.
In addition to the methods of Tables 3.2 to 3.5, list provides the methods

Merging of sorted lists:
=======================================================
Two small sorted lists are to be merged into one big sorted list. After the end of
the process, the calling list contains all elements of the two lists, whereas the called
list is empty. merge() is stable; thus, the relative order of the elements of a list is
maintained.
// k3/list/merge.cpp
#include<list>
#include<iostream>
// auxiliary function
void displayIntList(const std::list<int> & L) {
std::list<int>::const_iterator I = L.begin();
while(I != L.end())
	std::cout << *I++ << ’ ’;
	std::cout << " size() ="<< L.size() << std::endl;
}
int main( ) {
	std::list<int> L1, L2;
	// fill lists with sorted numbers
	for(int i = 0; i < 10; ++i) {
	L1.push_back(2*i); // even numbers
	L2.push_back(2*i+1); // odd numbers
	}
	displayIntList(L1); // 0 2 4 6 8 10 12 14 16 18 size() =10
	displayIntList(L2); // 1 3 5 7 9 11 13 15 17 19 size() =10
	L1.merge(L2); // merge
	displayIntList(L1);
	// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 size() =20
	displayIntList(L2); // size() =0
}
The example first outputs a list of even numbers and a list of odd numbers. After
the merge() operation, the first list contains all the numbers; the second list is
empty.

Splicing of lists
The term ‘splicing’ originates from the nautical cabling technique and denotes the
fastening together or uniting of several ropes by tucking several strands of rope or
cable into each other. Here, we talk about uniting lists. Of the possibilities listed in
Table 3.7, we only look at how to transfer a section of a list into another list. From
the previous example, only the line containing the merge() operation is substituted
with the following program fragment:

list<int>::iterator I = L2.begin();
advance(I, 4); // 4 steps
L1.splice(L1.begin(), L2, I, L2.end());
State of the lists before splice():
L1: 0 2 4 6 8 10 12 14 16 18
L2: 1 3 5 7 9 11 13 15 17 19
State of the lists after splice():
L1: 9 11 13 15 17 19 0 2 4 6 8 10 12 14 16 18
L2: 1 3 5 7
All elements of list L2 from position 4 (counting starts with 0) onward up to
the end of the list are transferred to the beginning of list L1. Afterwards, list L2
contains only the first four elements, whereas list L1 has grown by six elements at begin


Deque
Deque is an abbreviation for double ended queue. Like a vector, this sequence allows
random access iterators and, exactly like a list, it allows insertion and deletion at the
beginning or the end in constant time. Insertions and deletions somewhere in the
middle, however, are quite costly (O(n)), because many elements must be shifted.
A deque might be seen as being internally organized as an arrangement of several
memory blocks, where memory management is hidden in a similar way to vector.
During insertion at the beginning or the end, a new block of memory is added whenever
available space is no longer sufficient.

showSequence
A remark to start with: showSequence() is not an algorithm of the STL, but a
sequence display tool written for the examples in this book If nothing different is specified, output is written to cout. The sequence is output
completely, that is, from begin() to (but excluding) end(). The sep character
string separates the individual elements. It defaults to a space if nothing else is specified
in the function call. With these definitions, you can simply write
br_stl::showSequence(v);
in your program to display an int vector v, instead of
std::vector<int>::const_iterator iter = v.begin();
while(iter != v.end()) std::cout << *iter++ << " ";
std::cout << std::endl;
The function is neither designed for nor suited to simple C arrays. Its advantage
is that because of the shorter notation, programs become more readable. The
function template is read into memory with #include<showseq.h>. Inclusion of
#include<iostream> is done by showseq.h 

Types of iteraror :

template<class Iterator>
typename iterator_traits<Iterator>::iterator_category
get_iteratortype(const Iterator&) {
typename iterator_traits<Iterator>::iterator_category typeobject;
return typeobject;
}
// overloaded functions
void whichIterator(const input_iterator_tag&) {
cout << "Input iterator!" << endl;
}
void whichIterator(const output_iterator_tag&) {
cout << "Output iterator!" << endl;
}
void whichIterator(const forward_iterator_tag&) {
cout << "Forward iterator!" << endl;
}
void whichIterator(const random_access_iterator_tag&) {
cout << "Random access iterator!" << endl;
}
// application
int main( ) {
// In case of basic data types we have to use the iterator_traits template
int *ip; // random access iterator
// display of iterator type
whichIterator(get_iteratortype(ip));
whichIterator(
iterator_traits<int*>::iterator_category());
// define a file object for reading
// (actual file is not required here)
ifstream Source;
// an istream_iterator is an input iterator
istream_iterator<string> IPos(Source);
// display of iterator type
whichIterator(get_iteratortype(IPos)); // or alternatively:
whichIterator(iterator_traits<istream_iterator<string> >
::iterator_category());
// define a file object for writing
ofstream Destination;
// an ostream_iterator is an output iterator
ostream_iterator<string> OPos(Destination);
// display of iterator type
whichIterator(get_iteratortype(OPos)); // or alternatively:
whichIterator(iterator_traits<ostream_iterator<string> >
::iterator_category());
vector<int> v(10);
// display of iterator type
whichIterator(get_iteratortype(v.begin()));
// or some other iterator
whichIterator(iterator_traits<vector<int>::iterator>
::iterator_category());
}

// application
int main( ) {
// In case of basic data types we have to use the iterator_traits template
int *ip; // random access iterator
// display of iterator type
whichIterator(get_iteratortype(ip));
whichIterator(
iterator_traits<int*>::iterator_category());
// define a file object for reading
// (actual file is not required here)
ifstream Source;
// an istream_iterator is an input iterator
istream_iterator<string> IPos(Source);
// display of iterator type
whichIterator(get_iteratortype(IPos)); // or alternatively:
whichIterator(iterator_traits<istream_iterator<string> >
::iterator_category());
// define a file object for writing
ofstream Destination;
// an ostream_iterator is an output iterator
ostream_iterator<string> OPos(Destination);
// display of iterator type
whichIterator(get_iteratortype(OPos)); // or alternatively:
whichIterator(iterator_traits<ostream_iterator<string> >
::iterator_category());
vector<int> v(10);
// display of iterator type
whichIterator(get_iteratortype(v.begin()));
// or some other iterator
whichIterator(iterator_traits<vector<int>::iterator>
::iterator_category());
}
A furthther implementation show last elements 

// calling implementation
template<class Iterator>
void showLastElements(Iterator last,
typename std::iterator_traits<Iterator>::difference_type
n) {
typename std::iterator_traits<Iterator>::iterator_category
typeobject

showLastElements(last, n, typeobject);
}
/*This function now calls the corresponding overloaded variation, where the selection at
compile time is carried out by the parameter iterator_category() whose type
corresponds to an iterator tag. Therefore, the third parameter is an iterator tag object
constructed by calling its default constructor.
*/
// first overloaded function
template<class Iterator, class Distance>
void showLastElements(Iterator last, Distance n,
std::bidirectional_iterator_tag) {
Iterator temp = last;
std::advance(temp, -n);
while(temp != last) {
std::cout << *temp << ’ ’;
++temp;
}
std::cout << std::endl;
}
/*The bidirectional iterator does not allow random access and therefore no iterator arithmetic.
Only the operators ++ and -- are allowed for moving. Therefore, advance()
is used to go back n steps and then display the remaining elements. A random access
iterator allows arithmetic, which makes the implementation of this case slightly easier:
*/
// second overloaded function
template<class Iterator, class Distance>
void showLastElements(Iterator last, Distance n,
std::random_access_iterator_tag) {
Iterator first = last - n; // arithmetic
while(first != last)
std::cout << *first++ << ’ ’;
std::cout << std::endl;
}
// main-program
int main( ) {
std::list<int> L; // list
for(int i=0; i < 10; ++i) L.push_back(i);
// call of 1st implementation
showLastElements(L.end(), 5L); // 5 long
std::vector<int> v(10); // vector
for(int i = 0; i < 10; ++i) v[i] = i;
// call of 2nd implementation
showLastElements(v.end(), 5); // 5 int
}
This scheme – providing a function as an interface which then calls one of the
overloaded functions with the implementation – allows you to use completely different
implementations with one and the same function call.

Derivation of value and distance types
The STL is based on the fact that algorithms use iterators to work with containers.
However, this also means that inside an algorithm the container and its properties
are not known, and that all the required information must be contained in the iterators.
The information are determined by means of the iterator traits classes

#include<vector>
#include<iterator>
template<class BidirectionalIterator>
void reverseIt(BidirectionalIterator first,
BidirectionalIterator last) {
typename std::iterator_traits<BidirectionalIterator>
::iterator_category typeobject;
reverseIt(first, last, typeobject);
}
/*Reversing the order means that one element must be intermediately stored. For this, its
type must be known. Following the well-proven scheme, the function calls the suitable
implementation for the iterator type:
*/
template<class BidirectionalIterator>
void reverseIt(BidirectionalIterator first,
BidirectionalIterator last,
std::bidirectional_iterator_tag) {
// Use of the difference type to calculate the number of exchanges. The
// difference type is derived from the iterator type:
typename std::iterator_traits<
BidirectionalIterator>::difference_type
n = std::distance(first, last) -1;
while(n > 0) {
// The value type is also derived from the iterator type:
typename std::iterator_traits<BidirectionalIterator>
::value_type temp = *first;
*first++ = *--last;
*last = temp;
n -= 2;
}
}

Iterators for insertion into containers
The idiom shown on page 43
while(first != last) *result++ = *first++;
copies an input range into an output range, where oPos and iPos in Section 2.2.2
represent output and input iterators for streams. An output stream normally has more
than sufficient space for all copied elements container Source(100), Target(100);
// fill Source with values here
typename container::iterator first = Source.begin(),
last = Source.end(),
result = Target.begin();
// copying of the elements
while(first != last) *result++ = *first++;
There can, however, be a problem: this scheme fails when the Target container
is smaller than the Source container, because at some time result will no longer
The insert iterators provide the operators operator*() and operator++() in
both prefix and postfix version, together with operator=(). All operators return a
reference to the iterator. The first two have no other function. They exist only for
keeping the usual notation *result++ = *last++:
// Implementation of some operators (excerpt)
template <class Container>
class insert_iterator
: public iterator<output_iterator_tag,
typename Container::value_type,
typename Container::difference_type> {
public:
insert_iterator<Container>& operator*() {return *this;}
insert_iterator<Container>& operator++() {return *this;}
insert_iterator<Container>& operator++(int)
{ return *this;}
// ... and so on
};
Only the assignment operator calls a member function of the container, which is
dependent on the kind of container. Now Now, let us look at the expression *result++
= *last++ in detail, remembering that the order of evaluation is from right to left,
because unary operators are right-associative. *last is the value to be inserted. The
call of the first two operators yields a reference to the iterator itself
result.oper{zator++(int)}.operator*().operator=(*last++);
result.op{zerator*()}.operator=(*last++);
result.operator=(*last++);
The compiler optimizes the first two calls, so that the task of insertion only remains
with the assignment operator.

back_insert_iterator
A back insert iterator inserts new elements into a container at the end, making use
of the element function push_back() of the container, called by the assignment
operator:
// Implementation of an assignment operator
back_insert_iterator<Container>& operator=(
typename Container::const_reference value) {
// c points to the container (private pointer attribute of the iterator)
c->push_back(value);
return *this;
}
The following example shows the application of a back insert iterator in which
the numbers 1 and 2 are appended to a vector:
// k3/iterator/binsert.cpp
// Insert iterators : back insert
#include<showseq.h>
#include<vector>
#include<iterator>
int main() {
std::vector<int> aVector(5); // 5 zeros
std::cout << "aVector.size() = "
<< aVector.size() << std::endl; // 5
br_stl::showSequence(aVector); // 0 0 0 0 0
std::back_insert_iterator<std::vector<int> >
aBackInserter(aVector);
// insertion by means of the operations *, ++, =
int i = 1;
while(i < 3)
*aBackInserter++ = i++;
std::cout << "aVector.size() = "
<< aVector.size() << std::endl; // 7
br_stl::showSequence(aVector); // 0 0 0 0 0 1 2
}
The predefined function back_inserter() returns a back insert iterator and
facilitates passing iterators to functions. Let us assume a function copyadd() which
copies the contents of one container into another or adds it when the iterator used is
an insert iterator:
template <clasInputIterator, class OutputIterator>
OutputIterator copyadd(InputIterator first,
InputIterator last,
OutputIterator result) {
while (first != last)
*result++ = *first++;
return result;
}

Insertion iteraor:
The insertion position is stored in the private variable iter.
// k3/iterator/insert.cpp
// Insert iterator
#include<showseq>
#include<vector>
#include<iterator>
int main() {
std::vector<int> aVector(5); // 5 zeros
std::cout << "aVector.size() = "
<< aVector.size() << std::endl; // 5
br_stl::showSequence(aVector); // 0 0 0 0 0
// insertion by means of the operations *, ++, =
std::insert_iterator<std::vector<int> >
aBeginInserter(aVector, aVector.begin());
int i = 1;
while(i < 3) *aBeginInserter++ = i++;
// vector: 1 2 0 0 0 0 0, size() is now 7
/*In contrast to the front_insert_iterator, the insert-position remains the
same, i.e. after inserting an element the position is not the beginning of the vector!
*/
std::insert_iterator<vector<int> >
aMiddleInserter(aVector, aVector.begin() +
aVector.size()/2);
while(i < 6) *aMiddleInserter++ = i++;
// vector: 1 2 0 3 4 5 0 0 0 0, size() is now 10
std::insert_iterator<vector<int> >
anEndInserter(aVector, aVector.end());
while(i < 9) *anEndInserter++ = i++;
std::cout << "aVector.size() = "
<< aVector.size() << std::endl; // 13
br_stl::showSequence(aVector); // 1 2 0 3 4 5 0 0 0 0 6 7 8
}
Here, the insert iterator is used to insert elements at the beginning, in the middle,
tip and at the end. It should be noted that an insert iterator invalidates references to the
container when, for reasons of space, the container is moved to a different memory

Abstract data types
=======================
chapter first deals with
the abstract data types stack, queue, and priority_queue which are provided
as template classes by the STL. Subsequently, the sorted associative containers set,
map, multiset, and multimap are considered.
Stack
A stack is a container which allows insertion, retrieving, and deletion only at one
end. Objects inserted first are removed last. As an implicit data type, all sequential
container classes are allowed which support the operations back(), push_back(),
and pop_back() namespace std {
template <class T,
class Container = deque<T> > // default
class stack {
public:
typedef typename Container::value_type value_type;
typedef typename Container::size_type size_type;
typedef typename Container container_type;
protected:
Container c;
public:
explicit stack(const Container& = Container());
bool empty() const { return c.empty();}
size_type size() const { return c.size(); }
value_type& top() { return c.back(); }
const value_type& top() const { return c.back(); }
void push(const value_type& x) { c.push_back(x); }
void pop() { c.pop_back(); }
};
template <class T, class Container>
bool operator==(const stack<T,Container>& x,
const stack<T,Container>& y) {
return x.c == y.c;
}
template <class T, class Container>
bool operator<(const stack<T,Container>& x,
const stack<T,Container>& y) {
return x.c < y.c;
}
There are also the relational operators !=, <= etc. In particular, you can also
choose vector or list instead of the standard value deque.

Queue
A queue allows you to insert objects at one end and to remove them from the opposite
end. The objects at both ends of the queue can be read without being removed.
Both list and deque are suitable data types for implementation. The class queue
provides the following interface:
template<class T, class Container = deque<T> >
class queue {
public:
explicit queue(const Container& = Container());
typedef typename Container::value_type value_type;
typedef typename Container::size_type size_type;
typedef Container container_type;
bool empty() const;
size_type size() const;
value_type& front(); // read value in front
const value_type& front() const; // read value in front
value_type& back(); // read value at end
const value_type& back() const; // read value at end
void push(const value_type& x); // append x
void pop(); // delete first element
// private/protected parts omitted
};
Of course, the underlying implementation is very similar to that of the stack. The
operators == and < exist as well. queue::value_type and queue::size_type
are both derived from the type (deque or list) used for the container.
pplication of queue and stack as
simply as possible
#include<stack>
#include<queue>
#include<deque>
#include<list>
#include<vector>
#include<iostream>
int main() {
std::queue<int, std::list<int> > aQueue;
int numbers[] = {1, 5, 6, 0, 9, 1, 8, 7, 2};
const int count = sizeof(numbers)/sizeof(int);
std::cout << "Put numbers into the queue:" << std::endl;
for(int i = 0; i < count; ++i) {
std::cout.width(6); std::cout << numbers[i];
aQueue.push(numbers[i]);
}
std::stack<int> aStack;
std::cout << "\n\n Read numbers from the queue (same "
"order)\n and put them into the stack:"
<< std::endl;
while(!aQueue.empty()) {
int Z = aQueue.front(); // read value
std::cout.width(6); std::cout << Z;
aQueue.pop(); // delete value
aStack.push(Z);
}
This little program puts a sequence of int numbers into a queue, reads them back
out, and puts them on a stack. The stack is built with a deque (default), whereas the
queue uses a list (list).

Priority queue
A priority queue always returns the element with the highest priority. The priority
criterion must be specified when creating the queue. In the simplest case, it is the
greatest (or smallest) number in the queue. The criterion is characterized by a class
of suitable function objects for comparison 
priorities. For simplicity, only int elements are used
in the example. The continuation of the program of the previous section shows the
application, in which the priority queue internally uses a vector and employs the
standard comparison type greater:
// continued from Section 4.2
std::priority_queue<int, std::vector<int>,
std::greater<int> > aPrioQ;
// greater: small elements first (= high priority)
// less: large elements first
std::cout << "\n\n Read numbers from the stack "
"(reverse order!)\n"
" and put them into the priority queue:"
<< std::endl;
while(!aStack.empty()) {
int Z = aStack.top(); // read value
std::cout.width(6); std::cout << Z; // display
aStack.pop(); // delete value
aPrioQ.push(Z);
}
std::cout << "\n\n Read numbers from the priority "
" queue (sorted order!)" << std::endl;
while(!aPrioQ.empty()) {
int Z = aPrioQ.top(); // read value
std::cout.width(6); std::cout << Z; // display
aPrioQ.pop(); // delete value
}
}
Because of the priority queue’s internal representation as a binary heap for efficiency
reasons (see Section 5.7), only implicit data types with random access iterators
are suited, for example deque and vector. priority_queue provides the
following interfaces, where Container and Compare denote the data types for the
implicit container and the comparison type:
template<class T, class Container = vector<T>,
class Compare = less<Container::value_type> >
class priority_queue {
public:
typedef typename Container::value_type value_type;
typedef typename Container::size_type size_type;
typedef Container container_type;
bool empty() const;
size_type size() const;
const value_type& top() const;
void push(const value_type& x);
void pop();
The meaning of the above methods corresponds to that of stack and queue; the
constructor, however, looks slightly different:
explicit priority_queue(const Compare& x = Compare(),
const Container& = Container());
The constructor requires a Compare object. If none is passed, an object generated
by the default constructor of the Compare class is passed. In the sample program
above, this is greater<int>().
priority_queue(InputIterator first, InputIterator last,
const Compare& x = Compare(),
const Container& = Container());
This constructor takes input iterators as the argument, in order to create a priority
queue for a large range in one go. This is more efficient than a series of push()
operations. In our sample program on page 72, a further priority queue could be
created by means of the instruction
priority_queue<int, vector<int>, greater<int> >
anOtherPrioQ(numbers, numbers+count);
and at the same time be initialized with the whole number array. The name of the
array numbers is to be taken as a constant pointer, as is usual in C++.
Operators == and < do not exist because the comparison does not seem

Sorted associative containers
An associative container allows fast access to data by means of a key which need not
coincide with the data. For example, the name and address of an employee could be
accessed via a personnel number used as a key. In sets and multisets, the data itself is
used as a key, whereas in maps and multimaps, key and data are different. The STL
provides four types of associative containers:
• set: The keys coincide with the data. There are no elements with the same key in
the set, that is, a key occurs either once or it does not occur at all.
• multiset: The keys coincide with the data. There may be identical keys (elements)
in the set, that is, a key can occur not at all, once, or any number of times.
• map: The keys do not coincide with the data. For example, the key could be a
number (personnel number) by means of which the data (address, salary, ...) can
be accessed. Keys can be any kind of objects. In a dictionary, for example, the
key could be an English word which is used to determine a foreign language word
(the data). map maps a set of keys to a set of associated data. The elements of
a map container are pairs of keys and data. They describe a binary relation, that
is, a relation between elements of two sets. The set of possible keys is called the
‘definition range’ of the map, the set of associated data is called the ‘value range.’
The map type is characterized by a unique map, because one key is associated
with exactly one datum. There are no identical keys, that is, a key either does not
occur at all or occurs only once.
• multimap: A multimap object has the properties described under map, with one
exception: there may be identical keys. This means that a key can occur not at all,
once or any number of times. Unambiguousness is therefore no longer given.
The STL containers store the keys sorted, although this is not required by the
actual task described in the above points. This is just an implementation detail that
allows you to store these containers in a very compact way as balanced binary trees
(red-black trees). Because of the sorting, access to the elements is very fast and the
tree grows only by the strictly required amount.

Example for sets
#include<set>
#include<showseq.h>
int main() {
std::set<int> Set; // comparison object: less<int>()
for(int i = 0; i < 10; ++i) Set.insert(i);
for(int i = 0; i < 10; ++i) Set.insert(i); // no effect
br_stl::showSequence(Set); // 0 1 2 3 4 5 6 7 8 9
/*The display shows that the elements of the set really occur exactly once. In the next
part of the program, elements are deleted. In the first variation, first the element is
sought in order to delete it with the found iterator. In the second variation, deletion
is carried out via the specified key.
*/
std::cout << "Deletion by iterator\n"
"Delete which element? (0..9)" ;
int i;
std::cin >> i;
std::set<int>::const_iterator iter = Set.find(i);
if(iter == Set.end())
std::cout << i << " not found!\n";
else {
std::cout << "The element " << i
<< " exists" << Set.count(i) // 1
<< " times." << std::endl;
Set.erase(iter);
std::cout << i << " deleted!\n";
std::cout << "The element " << i
<< " exists" << Set.count(i) // 0
<< " times." << std::endl;
}
br_stl::showSequence(Set);
/*The count() method yields either 0 or 1. Thus, it is an indicator as to whether an
element is present in the set.
*/
std::cout << "Deletion by value\n"
"Delete which element? (0..9)" ;
std::cin >> i;
int Count = Set.erase(i);
if(Count == 0)
std::cout << i << " not found!\n";
br_stl::showSequence(Set);
/*A further set NumberSet is not initialized with a loop, but by specifying the range
to be inserted in the constructor. Suitable iterators for int values are pointers of
int* type. The name of a C array can be interpreted as a constant pointer to the
beginning of the array. When the number of array elements is added to this pointer,
the result is a pointer that points to the position after the last array element. Both
pointers can be used as iterators for initialization of a set:
*/
std::cout << "call constructor with iterator range\n";
// 2 and 1 twice!
int Array[] = { 1, 2, 2, 3, 4, 9, 13, 1, 0, 5};
Count = sizeof(Array)/sizeof(Array[0]);
std::set<int> NumberSet(Array, Array + Count);
br_stl::showSequence(NumberSet); // 0 1 2 3 4 5 9 13
}
In this example it can also be seen that the occurring elements are displayed only
once although duplicates exist in the original array.

Multiset
A multiset behaves like a set with the exception that not just one, but arbitrarily many
identical elements may be present. Table 4.4 shows insert() as the only method
which behaves differently from its counterpart in the set class and has a different
return type.
Return type method Meaning Complexity
iterator insert(t) Inserts the element t independently
of whether an element with the
same key already exists. The iterator
points to the newly inserted element

Map
Exactly like a set, a map is an associative container, in which, however, unlike set,
keys and associated data are different. Here, the difference between key_compare
and value_compare mentioned on page 75 takes effect. In the declaration of a set
container, the types of key and possibly comparison objects must be specified; in
map, the data type is needed as well:
map<int, string, greater<int> > aMap;
The definition is a mapping of int numbers onto string objects, with the
numbers internally sorted in descending order. As with set, sorting is not a property
of the map, but of internal storage. The type of the comparison object can
be left out: map<int, string> aMap is then the same as map<int, string,
less<int> > aMap.

The elements of a map container are pairs: the type value_type is identical
to key_type in set or multiset, whereas map::value_type is equivalent to
pair< Key, T>, with Key being the type of key and T the type of data.
The map class essentially provides constructors with the same parameters and
methods with the same names and parameters as the set class. The meaning is
equivalent; it is sufficient to remember that pairs are stored instead of single values.
There are only two exceptions. The method
value_compare value_comp();
differs in its meaning from the one in set. It returns a function object which can
be used for comparison of objects of type value_type (that is, pairs
pair<int, string> p(9921, "algorithms"),
q(2726, "data structures");
Now, if there is a map M which during construction was connected to the comparison
object CK for the comparison of keys, then the call
bool x = M.value_comp()(p,q);
is identical to
bool x = CK(p.first, q.first);
that is, the comparison of the keys stored in first. The second exception is the
index operator provided in map, which also allows you to access the data via the key
as an index. The key must not necessarily be a number:
// int key
cout << AddressMap[6]; // output of a name
// string key
cout << DictionaryMap["hello"]; // ‘Hallo

Example for map
#include<map>
#include<string>
#include<iostream>
using namespace std;
// two typedefs for abbreviations
// comparison object: less<long>()
typedef std::map<long, std::string> MapType;
typedef MapType::value_type ValuePair;
int main() {
MapType aMap;
aMap.insert(ValuePair(836361136, "Andrew"));
aMap.insert(ValuePair(274635328, "Berni"));
aMap.insert(ValuePair(260736622, "John"));
aMap.insert(ValuePair(720002287, "Karen"));
aMap.insert(ValuePair(138373498, "Thomas"));
aMap.insert(ValuePair(135353630, "William"));
// insertion of Xaviera is not executed, because the key already exists.
aMap.insert(ValuePair(720002287, "Xaviera"));
/*Owing to the underlying implementation, the output of the names is sorted by
numbers:
*/
std::cout << "Output:\n";
MapType::const_iterator iter = aMap.begin();
while(iter != aMap.end()) {
std::cout << (*iter).first << ’:’ // number
<< (*iter).second // name
<< std::endl;
++iter;
}
std::cout << "Output of the name after entering"
" the number\n"
<< "Number: ";
long Number;
std::cin >> Number;
iter = aMap.find(Number);
if(iter != aMap.end())
std::cout << (*iter).second // O(1)
<< ’ ’
<< Map[Number] // O(logN)
<< std:: endl;
elsestd:: cout << "Not found!" << std::endl;
}

Multimap
multimap differs from map in the same way as multiset differs from set:
multiple entries of elements with identical keys are possible, for example, the
name Xaviera in the sample program of the previous section.

Standard algorithms
Without especially mentioning it, all the algorithms presented in this chapter are
in namespace std. They are completely separated from the special implementation
of the containers on which they work. They only know iterators which can be used to
access the data structures in containers For this reason, iterators can be both complex objects and simple
pointers. Some algorithms bear the same names as container methods. However,
because of the different way in which they are used, no confusion will occur.
The complete separation can, however, also have disadvantages: a very generic
find() algorithm will have to search a container from beginning to end. The complexity
is O(N),

Copying algorithms
For reasons of speed, some algorithms exist in two variations: the first works directly
on the container, the second copies the container. The second variation is always
sensible when a copy process is required, for example to keep the original data, and
when, with regard to complexity, the algorithm itself

1. A copy B is to be made of container A, removing all elements from the copy which
satisfy a given condition, for example all clients with less than 50,000 dollars of
turnover. The following alternatives exist:
• copy A to B and remove all unwanted elements from B, or
• copy all elements from A to B, but only if they satisfy a given criterion.
Both alternatives are of complexity O(n).

2. A sorted copy B is to be generated of container A. Here too, two possibilities exist:
• copy A to B and sort B, or
• take all elements of A and insert them sorted into B.
The second possibility is no better than the first one. The sorting process is at
least of complexity O(N logN),

Algorithms with predicates
‘Predicate’ means a function object (see Section 1.6.3) which is passed to an algorithm
and returns a value of type bool when it is applied to a dereferenced iterator.
The dereferenced iterator is simply a reference to an object stored in the container.
The function object is to determine whether this object has a given property.
Only if this question is answered with true is the algorithm applied to this object.
A general scheme for this is:
template <class InputIterator, class Predicate>
void algorithm(InputIterator first,
InputIterator last,
Predicate pred) {
while (first != last) {
if(pred(*first)) { // does predicate apply?
show_it(*first); // ... or another function
}
++first;
}
}

Algorithms with binary predicates
A binary predicate requires two arguments. This allows you to formulate a condition
for two objects in the container, for example a comparison. The algorithm might
contain the following kernel:
if(binary_pred(*first, *second)) { // does the predicate apply?
do_something_with(*first, *second);
// ...
In this sense, you can also use objects of the classes of Table 1.2 as binary
predicates. The second parameter of a binary predicate, however, need not be an
iterator:
template <class InputIterator,
class binaryPredicate,
class T>
void another_algorithm(InputIterator first,
InputIterator last,
binaryPredicate bpred,
T aValue)
{ while (first != last) {
if(bpred(*first, aValue)) {
show_it(*first);
}
++first;
}
}
5.3 Nonmutating sequence operations
The algorithms described in this section work on sequences, but do not alter them.
With one exception, all algorithms are of complexity O(N), where N is the number
of elements in the sequence

for_each
The for_each algorithm causes a function to be executed on each element of a
container. The definition is so short and simple that it is shown in its entirety:
template <class InputIterator, class Function>
Function for_each(InputIterator first,
while(first != last)
	f(*first++);
		return f;
}
The returned object f is mostly ignored. However, the returned object can transport
data outside the function body, e.g. the maximum value of the iterated sequence.
In the following program, the function is the display of an int value which, together
with the for_each algorithm, writes a vector on the standard output.

#include<algorithm>
#include<vector>
#include<iostream>
using namespace std;
void display(int x) { // nonmutating function
	cout << x << ’ ’;
}
class Increment { // functor class
	public:
		Increment(int i = 1) : howmuch(i) {}
		void operator()(int& x) { // mutating operator
			x += howmuch;
		}
	private:
		int howmuch;
};
int main() {
vector<int> v(5); // vector of 5 zeros
// v is not changed:
for_each(v.begin(), v.end(), display); // 0 0 0 0 0
	cout << endl;
// with Increment constructor
// v is changed by the functor, not by for_each:
for_each(v.begin(), v.end(), Increment(2));
for_each(v.begin(), v.end(), display); // 2 2 2 2 2
	cout << endl;
// with Increment object
Increment anIncrement(7);

--------------------------------------------------------------------------------------------
Regular expression
A regular expression is an object defining a particular pattern to be matched against a sequence of characters
 using the tools of the standard regex library.

 :regex_match
 
 *********************
 Returns whether the target sequence matches the regular expression rgx. The target sequence is either s or the character sequence between first and last,
 depending on the version used.
 
  std::string s ("subject");
  std::regex e ("(sub)(.*)");  // match any thing after sub 
  
  std::smatch sm;    // same as std::match_results<string::const_iterator> sm;
  std::regex_match (s,sm,e);
  std::cout << "string object with " << sm.size() << " matches\n";

  for (unsigned i=0; i<sm.size(); ++i) {   //3 mathes subject sub ject
    std::cout << "[" << sm[i] << "] ";

	regex_search:
 *********************
Search sequence:
Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression rgx (the pattern). The target sequence is either s or the character sequence
between first and last, depending on the version used.

 
  std::regex e ("\\b(sub)([^ ]*)");  // only letters begining wd sub
  std::regex_search (s,m,e)
  
  
  }
 
 

--------------------------------------------------------------------------------------------


The answer is that C++ utilizes a hidden pointer named “this”!
class Simple
 
{
            void SetID(int nID) { m_nID = nID; }
     
}
	Simple a ;
	a.SetID(2);
Although it looks like this function only has one parameter, it actually has two! When you call cSimple.SetID(2);, C++ internally converts this to 
			SetID(&cSimple, 2);. 
Note that this is just a normal function call where C++ has added a parameter, and automatically passed in the address of the class object!
			
			void SetID(Simple* const this, int nID) 
			{ this->m_nID = = nID; }

this is a const pointer — you can change the value of the object it points to, but you can not make it point to something else!
Uses:
1)
	class Something

	{
 

	private:

   		int nData;
 

    		Something(int nData)

    		{
 

       			 this->nData = nData;

    		}
	}
2) Returning *this will return a reference to the object that was implicitly passed to the function by C++.

One use for this feature is that it allows a series of functions to be “chained” together, so that the output of one function becomes 
the input of another function!


4)-------------------------------------------------------------------------------------------------------------------------------------

Freind class :
*******************
Friend  is a declaration to the compiler saying that it allowed to modify the private variables of a class by the freind function or class.


Declaring as freind class one class to see the private variables of another class, even though these variables should probably not be made
 part of the public  interface that the class supports

class Node 
{
    private: 
    	int data;
    	int key;
    // ...

    friend class BinaryTree; // class BinaryTree can now access data directly
};


class BinaryTree

{

f(Node n)
{

Node *ptr = n;
ptr->data;

}


}


Points about freinds:
*I****************

1> Freinds can be declared at any access level(protected , public n all) but they can access private varirable

2> Freinds are not inherited by a derived class

32992221


Freind function:
*********************
Member functions and friend functions are equally privileged (100% vested). The major
difference is that a friend function is called like f(x), while a member function is called like x.f().
Thus the ability to choose between member functions (x.f()) and friend functions (f(x)) allows a
designer to select the syntax that is deemed most readable, which lowers maintenance costs.
The major disadvantage of friend functions is that they require an extra line of code when you
want dynamic binding. To get the effect of a virtual friend, the friend function should call a
hidden (usually protected) virtual member function. This is called the Virtual Friend Function
Idiom. For example:
class Base {
public:
friend void f(Base& b);
...
protected:
virtual void do_f();
...
};
inline void f(Base& b)
{
b.do_f();
}
class Derived : public Base {
public:
...
protected:
virtual void do_f(); // "Override" the behavior of f(Base& b)
...
};
void userCode(Base& b)
{
f(b);
}
The statement f(b) in userCode(Base&) will invoke b.do_f(), which is virtual. This means that
Derived::do_f() will get control if b is actually a object of class Derived. Note that Derived
overrides the behavior of the protected virtual member function do_f(); it does not have its own
variation of the friend function, f(Base&).
----------------------------------------------------------------------------------------------------------------

if(Number != -1) {
// use of container methods:
br_stl::slist<int>::iterator Position =
std::fin





-=------------------------------------------------------------------------------------------------------------------------------------------------------
The Template :

1) The compiler will generate Constructor / Destructors for the Data type whenever an explicit or Implicit declaration of the object
 is been done or a function call is been made 
********************************************************************

template <class T>
Class A
{

 T f()
 {
     return T;
 }

 T g()
 {
     return T;
 }


};

 main()
{

A <int> a1;   // The int version of constructor and destructor is defination is generated (IMPLICIT DECLARATION)

template <class T> 
A <int> b1;  // EXPLICIT DECLARATION)

a1.f();   // The int version of the function defination is generated  will be called  and g() 
is never been called    

}
3)Non type template parameters
******************************************************

A non-type template parameter must be an integral value that is known at compile time.
 You can make a fixed-size Stack, for instance, by specifying a non-type parameter to be used as the dimension for the 
 underlying array, as follows.

template<class T, size_t N> class Stack {
T data[N]; // Fixed capacity is N
size_t count;
public:
void push(const T& t);
// Etc.
};
 
You must provide a compile-time constant value for the parameter N when you request an instance of this template, such as

Stack<int, 100> myFixedStack;

2) The pointer towards a object of  int 
********************************************************************
A< int>* p_ai  =  new int ; // None of the version is generated 



3)  A templated Class Object is passed to  a template functon   
*************************************************************************
Declaration :   template<class T> void Fun(class A<T> p); 
Defination:  
	void Fun(class A<T> p)
	{
		

	}

4)  Functional Pointers as a templete type 
********************************************************************
The functional pointers is passing to as a lis 

list< void (*)() > a;

/* Or alternatively */
typedef void (*SimpleFunc)();
list< SimpleFunc > b;


5) Pointers to the  Template of type Class Pointer  and using New 
*****************************************************************************
LinkList<User*>* ptr = new LinkList<User*>();


6) Templates Can be declared as Static is allowed 
*****************************************************************************
static std::map<int, int> data;

7) 
*****************************************************************************
Template class:
A generic definition or a parameterized class not instantiated until the client provides the needed information.
It’s jargon for plain templates.



8) Multiple template clases
*****************************************************************************
If you don’t know what a function template is, then it would help if you read our quick refresher on function templates.

You may find yourself needing to use more than one type parameter in a function template. If that ever occurs, then 
declaring multiple type parameters is actually quite simple. All you need to do is add the extra type to the template
prefix, so it looks like this:


// 2 type parameters:
template<class T1, class T2>
void someFunc(T1 var1, T2 var2 )
{
// some code in here...
}
Can you have unused type parameters?

No, you may not. If you declare a template parameter then you absolutely must use it inside of your function definition 
otherwise the compiler will complain. So, in the example above, you would have to use both T1 and T2, or you will get
a compiler error.

Do template parameters have to be declared with a “T”?

No, the type parameter can actually be declared with any other identifier that you choose – as long as it not a keyword
in C++. Using “T” as the name for the type parameter is traditional, but remember that other names can be used.



Class template:
A class template specifies how individual classes can be constructed much like the way a class specifies how individual objects can be constructed. It’s jargon for plain classes. 
template<typename T> foo { } // class template

foo<int> t; // template class


Template Specialization
*******************************************************************************

In many cases when working with templates, you'll write one generic version for all possible data types and leave 
it at that--every vector may be implemented in exactly the same way. The idea of template specialization is to override 
the default template implementation to handle a particular type in a different way. 
template <typename T>
class vector
{
    // accessor functions and so forth
    private:
    T* vec_data;   // we'll store the data as block of dynamically allocated 
                   // memory
    int length;    // number of elements used 
    int vec_size;  // actual size of vec_data
};
But when it comes to bools, you might not really want to do this because most systems are going to use 16 or 32 bits 
for each boolean type even though all that's required is a single bit. So we might make our boolean vector look a little 
bit different by representing the data as an array of integers whose bits we manually manipulate. (For more on manipulating
bits directly, see bitwise operators and bit manipulations in C and C++.) 

To do this, we still need to specify that we're working with something akin to a template, but this time the list of template
 parameters will be empty:
 
template <>
and the class name is followed by the specialized type: class className<type>. In this case, the template would look like this:


template <>
class vector <bool>
{
    // interface

    private:
    unsigned int *vector_data;
    int length;
    int size;
};
Another time when you might want to specialize certain templates could be if you have a template type that relies on some
 behavior that was not implemented in a collection of classes you'd like to store in that template.


Template Partial Specialization
*****************************************************
Partial template specialization stems from similar motives as full specialization as described above. This time, however,
instead of implementing a class for one specific type, you end up implementing a template that still allows some
parameterization. That is, you write a template that specializes on one feature but still lets the class user choose other 
features as part of the template 

template <typename T>
class sortedVector<T *>
{
    public:
    // same functions as before.  Now the insert function looks like this:
    insert( T *val )
    {
        
    }

    private:
    T** vec_data;
    int length;
    int size;
};

when you allocate memory for an array of objects, the default constructor must be called to construct each object. 
If no default constructor exists (for instance, if every object needs some data to be created), you're stuck needing a
list of pointers to objects, but you probably want them to be sorted the same way the actual objects themselves would be! 

There are a couple of syntax points to notice here. First, our template parameter list still names T as the parameter, 
but the declaration now has a T * after the name of the class; this tells the compiler to match a pointer of any type
with this template instead of the more general template. The second thing to note is that T is now the type pointed to;
it is not itself a pointer. For instance, when you declare a sortedVector<int *>, T will refer to the int type
 
Note, by the way, that you can also partially specialize on template arguments--for instance, if you had a fixedVector 
type that allowed the user of the class to specify both a type to store and the length of the vector (possibly to avoid 
the cost of dynamic memory allocations), it might look something like this:

template <typename T, unsigned length>
class fixedVector { ... };
------------------------------------------------------------------------------------------------------------------------------------------------------
STREAMS:
The stream of bytes of data , which is used for I/O .
filestream: Has functions to close and open the files 
stringstrteam: Has functions to support Inmemory i/O , for copying and other stuffs .\

All of this classes are templted parameterized on char type
typedef basic_ifstream<char> ifstream

typedef basic_ifstream<wchar_t> wifstream

Global streams
------------------
1> stdinn, stdout, stderr






/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FILE HANDLING :

void write_file( char *filenames,char * filenamed)
{	
	long lsize;	
	char buff[100];
        FILE *fpd,*fps;
        fpd = fopen(filename,"a+");
        fps = fopen(filename,"rb");
	if(fps == NULL)
                perror("Eror opening the file");
	else{
                // obtain file size:
                fseek (fps,0 ,SEEK_END);//Starting from 0 to final end position
        y        lsize = ftell (fps);
                rewind (fps);
                result = fread (buff,1,lsize,fps);
	    }
        
	if(fpd == NULL)
                perror("Eror opening the file");

        else{
                fwrite(buff,lsize,1,fpd);
                fclose(fpd);
            }
}
-=------------------------------------------------------------------------------------------------------------------------------------------------------



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
